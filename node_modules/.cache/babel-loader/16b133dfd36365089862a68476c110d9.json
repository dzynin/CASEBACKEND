{"ast":null,"code":"/* eslint-disable max-len */\n/* eslint-disable no-constant-condition */\n/* eslint-disable no-useless-escape */\n/* eslint-disable prefer-rest-params */\n/* eslint-disable @typescript-eslint/tslint/config */\n/* eslint-disable security/detect-unsafe-regex */\n/* eslint-disable valid-jsdoc */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\n/**\n * Represents a 3D rendering configuration for the EJ 3D rendering engine.\n *\n */\nvar CircularChart3DRender = /** @class */function () {\n  function CircularChart3DRender() {\n    this.transform = null; // Chart3DBasicTransform\n  }\n  return CircularChart3DRender;\n}();\nexport { CircularChart3DRender };\nvar circular3DRender = new CircularChart3DRender();\n/**\n * Represents a circular 3D vector in space.\n */\nvar CircularChart3DVectorModule = /** @class */function () {\n  /**\n   * Constructs a new Vector3D instance.\n   *\n   * @constructor\n   * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n   * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n   * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n   */\n  function CircularChart3DVectorModule(pointX, vy, vz) {\n    /** The x-coordinate of the vector. */\n    this.x = 0;\n    /** The y-coordinate of the vector. */\n    this.y = 0;\n    /** The z-coordinate of the vector. */\n    this.z = 0;\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.00001;\n    this.x = pointX;\n    this.y = vy || 0;\n    this.z = vz || 0;\n  }\n  /**\n   * Checks if a vector is valid (not NaN for any component).\n   *\n   * @param {CircularChart3DVector} point - The vector to check.\n   * @returns {boolean} - True if the vector is valid, false otherwise.\n   */\n  CircularChart3DVectorModule.prototype.isValid = function (point) {\n    return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n  };\n  /**\n   * Creates a new Vector3D instance from provided coordinates.\n   *\n   * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n   * @param {number} vy - The y-coordinate.\n   * @param {number} vz - The z-coordinate.\n   * @returns {CircularChart3DVector} - The new Vector3D instance.\n   */\n  CircularChart3DVectorModule.prototype.vector3D = function (vx, vy, vz) {\n    this.x = vx;\n    this.y = vy;\n    this.z = vz;\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  };\n  /**\n   * Subtracts one vector from another and returns the result.\n   *\n   * @param {CircularChart3DVector} v1 - The first vector.\n   * @param {CircularChart3DVector} v2 - The second vector to subtract from the first.\n   * @returns {CircularChart3DVector} - The resulting vector.\n   */\n  CircularChart3DVectorModule.prototype.vector3DMinus = function (v1, v2) {\n    return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n  };\n  /**\n   * Adds two vectors and returns the result.\n   *\n   * @param {CircularChart3DVector} v1 - The first vector.\n   * @param {CircularChart3DVector} v2 - The second vector to add to the first.\n   * @returns {CircularChart3DVector} - The resulting vector.\n   */\n  CircularChart3DVectorModule.prototype.vector3DPlus = function (v1, v2) {\n    return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n  };\n  /**\n   * Multiplies two vectors using the cross product and returns the result.\n   *\n   * @param {CircularChart3DVector} v1 - The first vector.\n   * @param {CircularChart3DVector} v2 - The second vector.\n   * @returns {CircularChart3DVector} - The resulting vector.\n   */\n  CircularChart3DVectorModule.prototype.vector3DMultiply = function (v1, v2) {\n    var x = v1.y * v2.z - v2.y * v1.z;\n    var y = v1.z * v2.x - v2.z * v1.x;\n    var z = v1.x * v2.y - v2.x * v1.y;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the dot product of two vectors.\n   *\n   * @param {CircularChart3DVector} v1 - The first vector.\n   * @param {CircularChart3DVector} v2 - The second vector.\n   * @returns {number} - The dot product.\n   */\n  CircularChart3DVectorModule.prototype.vector3DAdd = function (v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  };\n  /**\n   * Multiplies a vector by a scalar value.\n   *\n   * @param {CircularChart3DVector} v1 - The vector to multiply.\n   * @param {number} value - The scalar value.\n   * @returns {CircularChart3DVector} - The resulting vector.\n   */\n  CircularChart3DVectorModule.prototype.vector3DStarMultiply = function (v1, value) {\n    var x = v1.x * value;\n    var y = v1.y * value;\n    var z = v1.z * value;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the length of a vector.\n   *\n   * @param {CircularChart3DVector} vector - The vector to calculate the length of.\n   * @returns {number} - The length of the vector.\n   */\n  CircularChart3DVectorModule.prototype.getLength = function (vector) {\n    var sqt = this.vector3DAdd(vector, vector);\n    return Math.sqrt(sqt);\n  };\n  /**\n   * Calculates the normal vector of a triangle defined by three vectors.\n   *\n   * @param {CircularChart3DVector} v1 - The first vertex of the triangle.\n   * @param {CircularChart3DVector} v2 - The second vertex of the triangle.\n   * @param {CircularChart3DVector} v3 - The third vertex of the triangle.\n   * @returns {CircularChart3DVector} - The normal vector of the triangle.\n   */\n  CircularChart3DVectorModule.prototype.getNormal = function (v1, v2, v3) {\n    var vector4 = this.vector3DMinus(v1, v2);\n    var vector5 = this.vector3DMinus(v3, v2);\n    var n = this.vector3DMultiply(vector4, vector5);\n    var length = this.getLength(n);\n    if (length < this.epsilon) {\n      return this.vector3D(0, 0, 0);\n    }\n    return this.vector3D(n.x / length, n.y / length, n.z / length);\n  };\n  return CircularChart3DVectorModule;\n}();\nexport { CircularChart3DVectorModule };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar CircularChart3DMatrix = /** @class */function () {\n  function CircularChart3DMatrix() {\n    /** The size of the matrix, which is set to 4 by default. */\n    this.matrixSize = 4;\n  }\n  /**\n   * Generates a 3D matrix of the specified size.\n   *\n   * @param {number} size - The size of the 3D matrix.\n   * @returns {number[][]} - The generated 3D matrix.\n   * @private\n   */\n  CircularChart3DMatrix.prototype.matrix3D = function (size) {\n    var matrixData = [];\n    for (var i = 0; i < size; i++) {\n      matrixData[i] = this.createArray(size);\n    }\n    return matrixData;\n  };\n  /**\n   * Checks if a matrix is an affine matrix.\n   *\n   * @param {number[][]} matrixData - The matrix to check.\n   * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n   */\n  CircularChart3DMatrix.prototype.isAffine = function (matrixData) {\n    return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n  };\n  /**\n   * Creates a new array with zeros.\n   *\n   * @param {number} initialSize - The size of the array.\n   * @returns {number[]} - The created array.\n   */\n  CircularChart3DMatrix.prototype.createArray = function (initialSize) {\n    var matrixData = [];\n    for (var index = 0; index < initialSize; ++index) {\n      matrixData[index] = 0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the identity matrix.\n   *\n   * @returns {number[][]} - The identity matrix.\n   */\n  CircularChart3DMatrix.prototype.getIdentity = function () {\n    var matrixData = this.matrix3D(this.matrixSize);\n    for (var i = 0; i < this.matrixSize; i++) {\n      matrixData[i][i] = 1.0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the interval of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix to get the interval for.\n   * @returns {number[][]} - The interval matrix.\n   */\n  CircularChart3DMatrix.prototype.getInterval = function (matrix) {\n    var matrixData = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        matrixData[i][j] = this.getMinor(matrix, i, j);\n      }\n    }\n    matrixData = this.transposed(matrixData);\n    matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n    return matrixData;\n  };\n  /**\n   * Multiplies all elements of a matrix by a factor.\n   *\n   * @param {number} factor - The factor to multiply with.\n   * @param {number[][]} matrix - The matrix to multiply.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  CircularChart3DMatrix.prototype.getMatrixMultiple = function (factor, matrix) {\n    for (var i = 0; i < matrix.length; i++) {\n      for (var j = 0; j < matrix[i].length; j++) {\n        matrix[i][j] = matrix[i][j] * factor;\n      }\n    }\n    return matrix;\n  };\n  /**\n   * Multiplies a matrix by a vector.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {CircularChart3DVector} point - The vector to multiply with.\n   * @returns {CircularChart3DVector} - The resulting vector.\n   */\n  CircularChart3DMatrix.prototype.getMatrixVectorMultiple = function (matrix, point) {\n    var x = matrix[0][0] * point.x + matrix[1][0] * point.y + matrix[2][0] * point.z + matrix[3][0];\n    var y = matrix[0][1] * point.x + matrix[1][1] * point.y + matrix[2][1] * point.z + matrix[3][1];\n    var z = matrix[0][2] * point.x + matrix[1][2] * point.y + matrix[2][2] * point.z + matrix[3][2];\n    if (!this.isAffine(matrix)) {\n      var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n      x *= c;\n      y *= c;\n      z *= c;\n    }\n    return {\n      x: x,\n      y: y,\n      z: z\n    };\n  };\n  /**\n   * Multiplies two matrices.\n   *\n   * @param {number[][]} matrix1 - The first matrix.\n   * @param {number[][]} matrix2 - The second matrix.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  CircularChart3DMatrix.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n    var result = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        var value = 0;\n        for (var k = 0; k < this.matrixSize; k++) {\n          value += matrix1[k][j] * matrix2[i][k];\n        }\n        result[i][j] = value;\n      }\n    }\n    return result;\n  };\n  /**\n   * Gets the minor of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number} - The minor of the matrix.\n   * @private\n   */\n  CircularChart3DMatrix.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n    return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n  };\n  /**\n   * Gets a submatrix of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number[][]} - The submatrix.\n   */\n  CircularChart3DMatrix.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n    var count = matrix.length - 1;\n    var subMatrix = this.createArray(count);\n    for (var i = 0; i < count; i++) {\n      var matrixColumn = i >= columnIndex ? i + 1 : i;\n      subMatrix[i] = this.createArray(count);\n      for (var j = 0; j < count; j++) {\n        var matrixRow = j >= rowIndex ? j + 1 : j;\n        subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n      }\n    }\n    return subMatrix;\n  };\n  /**\n   * Gets the determinant of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @returns {number} - The determinant of the matrix.\n   */\n  CircularChart3DMatrix.prototype.getDeterminant = function (matrix) {\n    var count = matrix.length;\n    var determinant = 0;\n    if (count < 2) {\n      determinant = matrix[0][0];\n    } else {\n      var k = 1;\n      for (var i = 0; i < count; i++) {\n        var submatrix = this.getMatrix(matrix, i, 0);\n        determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n        k = k > 0 ? -1 : 1;\n      }\n    }\n    return determinant;\n  };\n  /**\n   * Transforms a matrix by translation.\n   *\n   * @param {number} x - The x-coordinate of the translation.\n   * @param {number} y - The y-coordinate of the translation.\n   * @param {number} z - The z-coordinate of the translation.\n   * @returns {number[][]} - The transformed matrix.\n   */\n  CircularChart3DMatrix.prototype.transform = function (x, y, z) {\n    var transformedMatrix = this.getIdentity();\n    transformedMatrix[3][0] = x;\n    transformedMatrix[3][1] = y;\n    transformedMatrix[3][2] = z;\n    return transformedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the y-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   * @private\n   */\n  CircularChart3DMatrix.prototype.turn = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[0][0] = Math.cos(angle);\n    rotatedMatrix[2][0] = -Math.sin(angle);\n    rotatedMatrix[0][2] = Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the x-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   */\n  CircularChart3DMatrix.prototype.tilt = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[1][1] = Math.cos(angle);\n    rotatedMatrix[2][1] = Math.sin(angle);\n    rotatedMatrix[1][2] = -Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Transposes a matrix.\n   *\n   * @param {number[][]} matrix3D - The matrix to transpose.\n   * @returns {number[][]} - The transposed matrix.\n   */\n  CircularChart3DMatrix.prototype.transposed = function (matrix3D) {\n    var transposedMatrix = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        transposedMatrix[i][j] = matrix3D[j][i];\n      }\n    }\n    return transposedMatrix;\n  };\n  return CircularChart3DMatrix;\n}();\nexport { CircularChart3DMatrix };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar CircularChart3DTransform = /** @class */function () {\n  /**\n   * Initializes a new instance of the `ChartTransform` class.\n   */\n  function CircularChart3DTransform() {\n    /** Represents the angle conversion factor from degrees to radians. */\n    this.toRadial = Math.PI / 180;\n    this.vector = new CircularChart3DVectorModule(0, 0, 0);\n    this.matrixObj = new CircularChart3DMatrix();\n  }\n  /**\n   * Creates a 3D transformation based on the specified size.\n   *\n   * @param {Size} size - The size of the viewing area.\n   * @returns {CircularChart3DBasicTransform} - The 3D transformation.\n   */\n  CircularChart3DTransform.prototype.transform3D = function (size) {\n    return {\n      viewingArea: size,\n      rotation: 0,\n      tilt: 0,\n      depth: 0,\n      perspectiveAngle: 0,\n      needUpdate: true,\n      centeredMatrix: this.matrixObj.getIdentity(),\n      perspective: this.matrixObj.getIdentity(),\n      resultMatrix: this.matrixObj.getIdentity(),\n      viewMatrix: this.matrixObj.getIdentity()\n    };\n  };\n  /**\n   * Applies the specified 3D transformation to the current state.\n   *\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation to apply.\n   * @returns {void} - The 3D transformation.\n   */\n  CircularChart3DTransform.prototype.transform = function (transform) {\n    this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n    this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n    this.updatePerspective(transform.perspectiveAngle, transform);\n    transform.needUpdate = true;\n  };\n  /**\n   * Updates the perspective matrix based on the specified angle.\n   *\n   * @param {number} angle - The perspective angle.\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  CircularChart3DTransform.prototype.updatePerspective = function (angle, transform) {\n    var width = (transform.viewingArea.width + transform.viewingArea.height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0)) + transform.depth * 2 / 2;\n    transform.perspective[0][0] = width;\n    transform.perspective[1][1] = width;\n    transform.perspective[2][3] = 1;\n    transform.perspective[3][3] = width;\n  };\n  /**\n   * Converts degrees to radians.\n   *\n   * @param {number} angle - The angle in degrees.\n   * @returns {number} - The angle in radians.\n   * @private\n   */\n  CircularChart3DTransform.prototype.degreeToRadianConverter = function (angle) {\n    return angle * Math.PI / 180;\n  };\n  /**\n   * Transforms a 3D vector to screen coordinates based on the current state.\n   *\n   * @param {CircularChart3DVector} vector3D - The 3D vector to transform.\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n   * @param {CircularChart3DMatrix} chartObj - Optional custom matrix object for transformation.\n   * @returns {CircularChart3DLocation} - The screen coordinates.\n   */\n  CircularChart3DTransform.prototype.toScreen = function (vector3D, transform, chartObj) {\n    if (!chartObj) {\n      transform.chartObj = this.matrixObj;\n      vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n    } else {\n      this.matrixObj = chartObj;\n      vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n    }\n    return {\n      x: vector3D.x,\n      y: vector3D.y\n    };\n  };\n  /**\n   * Sets the view matrix in the transformation state.\n   *\n   * @param {number[][]} matrix - The new view matrix.\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  CircularChart3DTransform.prototype.setViewMatrix = function (matrix, transform) {\n    if (transform.viewMatrix === matrix) {\n      return;\n    }\n    transform.viewMatrix = matrix;\n    transform.needUpdate = true;\n  };\n  /**\n   * Calculates the final result matrix based on the current state.\n   *\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n   * @param {CircularChart3DMatrix} matrixobj - Optional custom matrix object for transformation.\n   * @returns {number[][]} - The final result matrix.\n   */\n  CircularChart3DTransform.prototype.result = function (transform, matrixobj) {\n    var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n    if (!chartObj) {\n      chartObj = matrixobj;\n    }\n    if (!transform.needUpdate) {\n      return transform.resultMatrix;\n    }\n    var matrixObj = this.matrixObj;\n    transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n    transform.needUpdate = false;\n    return transform.resultMatrix;\n  };\n  /**\n   * Sets the center in the transformation state.\n   *\n   * @param {CircularChart3DVector} center - The new center vector.\n   * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  CircularChart3DTransform.prototype.setCenter = function (center, transform) {\n    transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n    transform.needUpdate = true;\n  };\n  return CircularChart3DTransform;\n}();\nexport { CircularChart3DTransform };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n * @class\n */\nvar CircularChart3DGraphics = /** @class */function () {\n  function CircularChart3DGraphics() {\n    /** The vector class. */\n    this.vector = new CircularChart3DVectorModule(0, 0, 0);\n  }\n  /**\n   * Prepares the view for rendering based on specified parameters.\n   *\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n   * @returns {void}\n   */\n  CircularChart3DGraphics.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n    if (arguments.length === 0) {\n      bspTreeObj.build(null, chart);\n    } else {\n      if (circular3DRender.transform == null) {\n        circular3DRender.transform = chart.transform3D.transform3D(size);\n      } else {\n        circular3DRender.transform.viewingArea = size;\n      }\n      if (!circular3DRender.tree) {\n        circular3DRender.tree = [];\n      }\n      circular3DRender.transform.rotation = rotation;\n      circular3DRender.transform.tilt = tilt;\n      circular3DRender.transform.depth = depth;\n      circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n      chart.transform3D.transform(circular3DRender.transform);\n      circular3DRender.tree[chart.groupElement.id] = bspTreeObj.build(null, chart);\n    }\n  };\n  /**\n   * Renders the 3D view on the specified panel element.\n   *\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @returns {void}\n   */\n  CircularChart3DGraphics.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n    var MaxValue = 32767;\n    if (arguments.length === 2) {\n      if (panel == null) {\n        return;\n      }\n      var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eyeVector, panel, chart);\n    } else {\n      if (panel == null) {\n        return;\n      }\n      if (circular3DRender.transform == null) {\n        circular3DRender.transform = chart.transform3D.transform3D(size);\n      } else {\n        circular3DRender.transform.viewingArea = size;\n      }\n      circular3DRender.transform.rotation = rotation;\n      circular3DRender.transform.tilt = tilt;\n      circular3DRender.transform.depth = depth;\n      circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n      chart.transform3D.transform(circular3DRender.transform);\n      var eye = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eye, panel, chart);\n    }\n  };\n  /**\n   * Draws a 3D element based on the specified Binary Space Partitioning Node.\n   *\n   * @param {CircularChart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n   * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n   * @returns {void}\n   */\n  CircularChart3DGraphics.prototype.draw3DElement = function (bspElement, chart) {\n    if (bspElement.plane.element) {\n      if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n        polygonObj.drawText(bspElement.plane, chart);\n      } else if (bspElement.plane.element.tag === 'polyline') {\n        polygonObj.drawPolyLine(bspElement.plane, chart);\n      } else if (bspElement.plane.element.tag === 'template') {\n        polygonObj.drawTemplate(bspElement.plane, chart);\n      }\n    } else {\n      polygonObj.draw(bspElement.plane, chart);\n    }\n  };\n  /**\n   * Draws the 3D nodes starting from the root based on the eye vector.\n   *\n   * @param {CircularChart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n   * @param {CircularChart3DVector} eyeVector - The eye vector.\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n   * @returns {void}\n   */\n  CircularChart3DGraphics.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n    if (bspElement === null || circular3DRender.transform == null) {\n      return;\n    }\n    while (true) {\n      var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(circular3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n      if (r > bspElement.plane.d) {\n        if (bspElement.front != null) {\n          this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.back != null) {\n          bspElement = bspElement.back;\n          continue;\n        }\n      } else {\n        if (bspElement.back != null) {\n          this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.front != null) {\n          bspElement = bspElement.front;\n          continue;\n        }\n      }\n      break;\n    }\n  };\n  return CircularChart3DGraphics;\n}();\nexport { CircularChart3DGraphics };\n/**\n * Represents a binary tree builder for 3D polygons in a circular 3D chart.\n *\n */\nvar CircularChart3DBinaryTreeBuilder = /** @class */function () {\n  function CircularChart3DBinaryTreeBuilder(chart) {\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.0005;\n    this.chart = chart;\n  }\n  /**\n   * Gets the next index considering the array length and the current index.\n   *\n   * @param {number} index - The current index.\n   * @param {number} count - The length of the array.\n   * @returns {number} - The next index.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.getNext = function (index, count) {\n    if (index >= count) {\n      return index - count;\n    }\n    if (index < 0) {\n      return index + count;\n    }\n    return index;\n  };\n  /**\n   * Creates a PolyAttributes object based on the vector, index, and result.\n   *\n   * @param {CircularChart3DVector} point - The vector representing the point.\n   * @param {number} index - The index of the point.\n   * @param {string} result - The result classification.\n   * @returns {CircularChart3DPolyAttributes} - The created PolyAttributes object.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n    return {\n      index: index,\n      result: result,\n      vector: point,\n      isCuttingBackPoint: false,\n      cuttingBackPairIndex: null,\n      alreadyCutBack: false,\n      isCuttingFrontPoint: false,\n      cuttingFrontPairIndex: null,\n      alreadyCutFront: false\n    };\n  };\n  /**\n   * Classifies a point relative to a polygon.\n   *\n   * @param {CircularChart3DVector} point - The point to classify.\n   * @param {CircularChart3DPolygon} polygon - The polygon for classification.\n   * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n    var result = 'OnPlane';\n    var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n    if (signedDistance > this.epsilon) {\n      result = 'OnBack';\n    } else if (signedDistance < -this.epsilon) {\n      result = 'OnFront';\n    }\n    return result;\n  };\n  /**\n   * Classifies a polygon relative to another polygon.\n   *\n   * @param {CircularChart3DPolygon} refPolygon - The reference polygon.\n   * @param {CircularChart3DPolygon} classPolygon - The polygon to classify.\n   * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n    var result = 'Unknown';\n    var points = classPolygon.points;\n    if (points == null) {\n      return result;\n    }\n    var onBack = 0;\n    var onFront = 0;\n    var onPlane = 0;\n    var normal = refPolygon.normal;\n    var polygonValue = refPolygon.d;\n    for (var i = 0, len = points.length; i < len; i++) {\n      var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n      if (value > this.epsilon) {\n        onBack++;\n      } else if (value < -this.epsilon) {\n        onFront++;\n      } else {\n        onPlane++;\n      }\n      if (onBack > 0 && onFront > 0) {\n        break;\n      }\n    }\n    if (onPlane === points.length) {\n      result = 'OnPlane';\n    } else if (onFront + onPlane === points.length) {\n      result = 'ToRight';\n    } else if (onBack + onPlane === points.length) {\n      result = 'ToLeft';\n    } else {\n      result = 'Unknown';\n    }\n    return result;\n  };\n  /**\n   * Splits a polygon into two parts based on another polygon.\n   *\n   * @param {CircularChart3DPolygon} splitPolygon - The polygon to split.\n   * @param {CircularChart3DPolygon} refPolygon - The reference polygon for splitting.\n   * @returns {CircularChart3DPolyCollections} - The resulting back and front parts.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n    var backPoint = [];\n    var frontPoint = [];\n    if (splitPolygon.points != null) {\n      var polyPoints = [];\n      var backPartPoints = [];\n      var frontPartPoints = [];\n      var outputs = void 0;\n      var inputs = void 0;\n      var count = splitPolygon.points.length;\n      for (var i = 0; i < count; i++) {\n        var pointB = splitPolygon.points[i];\n        var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n        var sideB = this.classifyPoint(pointB, refPolygon);\n        var sideC = this.classifyPoint(pointC, refPolygon);\n        var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n        polyPoints.push(attributeB);\n        if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n          var vectorValue = vector.vector3DMinus(pointB, pointC);\n          var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n          var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n          var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n          var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n          var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n          polyPoints.push(attributeIntersection);\n          backPartPoints.push(attributeIntersection);\n          frontPartPoints.push(attributeIntersection);\n        }\n      }\n      if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n        for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n          var backAttribute1 = backPartPoints[i];\n          var backAttribute2 = backPartPoints[i + 1];\n          backAttribute1.cuttingBackPoint = true;\n          backAttribute2.cuttingBackPoint = true;\n          backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n          backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n          var frontAttribute1 = frontPartPoints[i];\n          var frontAttribute2 = frontPartPoints[i + 1];\n          frontAttribute1.cuttingFrontPoint = true;\n          frontAttribute2.cuttingFrontPoint = true;\n          frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n          frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n        }\n        for (var i = 0; i < backPartPoints.length - 1; i++) {\n          var backAttribute1 = backPartPoints[i];\n          if (backAttribute1.alreadyCutBack) {\n            continue;\n          }\n          outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n          if (outputs.length > 2) {\n            var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n            backPoint.push(__assign({}, polygon1));\n          }\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i++) {\n          var backAttribute2 = frontPartPoints[i];\n          if (backAttribute2.alreadyCutFront) {\n            continue;\n          }\n          inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n          if (inputs.length > 2) {\n            var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n            frontPoint.push(__assign({}, polygon2));\n          }\n        }\n      }\n    } else {\n      backPoint.push(splitPolygon);\n      frontPoint.push(splitPolygon);\n    }\n    return {\n      backPolygon: backPoint,\n      frontPolygon: frontPoint\n    };\n  };\n  /**\n   * Cuts out the front part of a polygon based on the PolyAttributes.\n   *\n   * @param {CircularChart3DPolyAttributes[]} polyPoints - The polyAttributes array of the polygon.\n   * @param {CircularChart3DPolyAttributes} initialVertex - The polyAttributes representing the cutting point.\n   * @returns {CircularChart3DVector[]} - The resulting points of the front part.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    while (true) {\n      currentVertex.alreadyCutFront = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n      if (currentVertex.cuttingFrontPoint) {\n        if (!currentVertexPair.alreadyCutFront) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n  };\n  /**\n   * Cuts out the back part of a polygon based on the PolyAttributes.\n   *\n   * @param {CircularChart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n   * @param {CircularChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n   * @returns {CircularChart3DVector[]} - The resulting points of the back part.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    while (true) {\n      currentVertex.alreadyCutBack = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n      if (currentVertex.cuttingBackPoint) {\n        if (!currentVertexPair.alreadyCutBack) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n  };\n  /**\n   * Builds a binary space partitioning from a list of polygons.\n   *\n   * @param {CircularChart3DPolygon[]} [points] - The list of polygons to build the tree from.\n   * @param {CircularChart3D} [chart] - The circular 3D chart.\n   * @returns {CircularChart3DBspNode} - The root node of the Binary Space Partitioning tree.\n   */\n  CircularChart3DBinaryTreeBuilder.prototype.build = function (points, chart) {\n    if (!arguments[0]) {\n      return this.build(chart.circular3DPolygon);\n    } else {\n      var inputPolygons = arguments[0];\n      if (inputPolygons.length < 1) {\n        return null;\n      }\n      var bspNode = {\n        back: null,\n        front: null,\n        plane: null\n      };\n      var plane = inputPolygons[0];\n      bspNode.plane = plane;\n      var polygonsToLeft = [];\n      var polygonsToRight = [];\n      for (var i = 1, len = inputPolygons.length; i < len; i++) {\n        var currentPolygon = inputPolygons[i];\n        if (currentPolygon === plane) {\n          continue;\n        }\n        var classificationResult = this.classifyPolygon(plane, currentPolygon);\n        switch (classificationResult) {\n          case 'OnPlane':\n          case 'ToRight':\n            polygonsToRight.push(currentPolygon);\n            break;\n          case 'ToLeft':\n            polygonsToLeft.push(currentPolygon);\n            break;\n          case 'Unknown':\n            if (currentPolygon.element) {\n              polygonsToLeft.push(currentPolygon);\n            } else {\n              var result = this.splitPolygon(currentPolygon, plane);\n              for (var k = 0; k < result.backPolygon.length; k++) {\n                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                polygonsToLeft.push(result.backPolygon[k]);\n              }\n              for (var j = 0; j < result.frontPolygon.length; j++) {\n                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                polygonsToRight.push(result.frontPolygon[j]);\n              }\n            }\n            break;\n        }\n      }\n      if (polygonsToLeft.length > 0) {\n        bspNode.back = this.build(polygonsToLeft);\n      }\n      if (polygonsToRight.length > 0) {\n        bspNode.front = this.build(polygonsToRight);\n      }\n      return bspNode;\n    }\n  };\n  return CircularChart3DBinaryTreeBuilder;\n}();\nexport { CircularChart3DBinaryTreeBuilder };\n/**\n * The CircularChart3DSvgRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar CircularChart3DSvgRenderer = /** @class */function () {\n  function CircularChart3DSvgRenderer() {}\n  /**\n   * Gets a CircularChart3DStringBuilder instance for constructing strings.\n   *\n   * @returns {CircularChart3DStringBuilder} - The StringBuilder instance.\n   */\n  CircularChart3DSvgRenderer.prototype.getStringBuilder = function () {\n    var data = [];\n    var counter = 0;\n    return {\n      append: function (text) {\n        data[counter++] = text;\n        return this;\n      },\n      toString: function (text) {\n        return data.join(text || '');\n      }\n    };\n  };\n  /**\n   * Parses a hex color code and returns its Red green Blue values.\n   *\n   * @param {string} hexColorCode - The hex color code.\n   * @returns {CircularChart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n   */\n  CircularChart3DSvgRenderer.prototype.hexToValue = function (hexColorCode) {\n    var rgbRegex = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.test(hexColorCode);\n    var result;\n    if (rgbRegex === true) {\n      result = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.exec(hexColorCode);\n      return result ? {\n        red: parseInt(result[1], 10),\n        green: parseInt(result[2], 10),\n        blue: parseInt(result[3], 10),\n        alpha: result[4]\n      } : null;\n    } else {\n      result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n      return result ? {\n        red: parseInt(result[1], 16),\n        green: parseInt(result[2], 16),\n        blue: parseInt(result[3], 16)\n      } : null;\n    }\n  };\n  /**\n   * Draws text on an SVG element.\n   *\n   * @param {SVGCanvasAttributes} options - The options for drawing the text.\n   * @param {string | string[]} label - The text label.\n   * @param {FontModel} font - The font settings for the text.\n   * @param {CircularChart3D} chart - The circular 3D chart instance.\n   * @returns {Element} - The created SVG text element.\n   */\n  CircularChart3DSvgRenderer.prototype.drawText = function (options, label, font, chart) {\n    var text = document.getElementById(options.id) || chart.groupElement.querySelector('#' + options.id);\n    if (text === null) {\n      text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    }\n    text.textContent = label;\n    text = chart.renderer.setElementAttributes(options, text);\n    return text;\n  };\n  /**\n   * Converts a CircularChart3DColorFormat object to its corresponding color string.\n   *\n   * @param {CircularChart3DColorFormat} color - The color in CircularChart3DColorFormat.\n   * @returns {string} - The color string representation.\n   */\n  CircularChart3DSvgRenderer.prototype.hexColor = function (color) {\n    var redValue = color.red;\n    var greenValue = color.green;\n    var blueValue = color.blue;\n    if (color.alpha) {\n      var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n      return returnColor;\n    } else {\n      var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n      hex_1.forEach(function (val, nr) {\n        if (val.length === 1) {\n          hex_1[nr] = '0' + val;\n        }\n      });\n      return '#' + hex_1.join('').toUpperCase();\n    }\n  };\n  /**\n   * Checks if a given color string is in a valid format (hex or rgba).\n   *\n   * @param {string} color - The color string to check.\n   * @returns {boolean} - True if the color string is valid, otherwise false.\n   */\n  CircularChart3DSvgRenderer.prototype.checkColorFormat = function (color) {\n    var regex = /(rgba?\\((?:\\d{1,3}[,\\)]){3}(?:\\d+\\.\\d+\\))?)|(^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$)/gmi.test(color);\n    return regex;\n  };\n  return CircularChart3DSvgRenderer;\n}();\nexport { CircularChart3DSvgRenderer };\n/**\n * Represents a 3D polygon in a circular 3D chart.\n *\n */\nvar CircularChart3DPolygonModule = /** @class */function () {\n  function CircularChart3DPolygonModule() {\n    this.epsilon = 0.00001;\n    this.normal = {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n    this.vector = new CircularChart3DVectorModule(0, 0, 0);\n    this.vectorPoints = [];\n    this.matrixObj = new CircularChart3DMatrix();\n  }\n  /**\n   * Creates a 3D polygon.\n   *\n   * @param {CircularChart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n   * @param {CircularChart3DPolygon} [tag] - Additional information or metadata for the polygon.\n   * @param {number} [index] - An index associated with the polygon.\n   * @param {string} [stroke] - The stroke color of the polygon.\n   * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n   * @param {number} [opacity] - The opacity of the polygon.\n   * @param {string} [fill] - The fill color of the polygon.\n   * @param {string} [name] - The name or identifier of the polygon.\n   * @param {Element} [parent] - The parent element to which the polygon belongs.\n   * @param {string} [text] - Additional text associated with the polygon.\n   * @returns {CircularChart3DPolygon} - Returns the created polygon.\n   */\n  CircularChart3DPolygonModule.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n    if (arguments.length === 2) {\n      points = arguments[0];\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var polygon = arguments[1];\n      polygon.normal = this.normal;\n      polygon.points = points;\n      polygon.vectorPoints = this.vectorPoints;\n      polygon.isSplit = true;\n      polygon.d = this.d;\n      return polygon;\n    } else {\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var element = {\n        tag: 'path',\n        parent: parent\n      };\n      var polygon = {\n        normal: this.normal,\n        points: points,\n        vectorPoints: this.vectorPoints,\n        index: index,\n        tag: tag,\n        name: name ? name : null,\n        strokeThickness: strokeThickness,\n        opacity: opacity,\n        fill: fill,\n        d: this.d,\n        text: text ? text : '',\n        polygonElement: element\n      };\n      if (arguments.length !== 1) {\n        polygon.polygonElement = element;\n      }\n      return polygon;\n    }\n  };\n  /**\n   * Calculates the normal vector for a 3D polygon based on the provided points.\n   *\n   * @param {...CircularChart3DVector} args - Variable number of vector3D arguments representing points of the polygon.\n   * @returns {void}\n   */\n  CircularChart3DPolygonModule.prototype.calculateNormal = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (args.length >= 3) {\n      // Relative information of the points\n      var vector1 = args[0];\n      var vector2 = args[1];\n      var vector3 = args[2];\n      var vector4 = this.vector.vector3DMinus(vector1, vector2);\n      var vector5 = this.vector.vector3DMinus(vector3, vector2);\n      var normal = this.vector.vector3DMultiply(vector4, vector5);\n      var length_1 = this.vector.getLength(normal); // Get length of the vector\n      if (length_1 < this.epsilon) {\n        length_1 = 1;\n      }\n      this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n      this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n      if (args[3]) {\n        args[3].normal = this.normal;\n        args[3].d = this.d;\n      }\n    } else {\n      var points = args[0];\n      this.calculateNormal(points[0], points[1], points[2], arguments[1]);\n      for (var i = 3; i < points.length && this.test(); i++) {\n        this.calculateNormal(points[i], points[0], points[i / 2]);\n      }\n    }\n  };\n  /**\n   * Tests whether the calculated normal vector is valid.\n   *\n   * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n   */\n  CircularChart3DPolygonModule.prototype.test = function () {\n    return !this.vector.isValid(this.normal);\n  };\n  /**\n   * Gets the normal vector based on the transformed points using the specified transformation matrix.\n   *\n   * @param {number[][]} transform - The transformation matrix.\n   * @param {CircularChart3DVector[]} [vectorPoints] - The vector points.\n   * @returns {CircularChart3DVector} - Returns the normal vector.\n   * @private\n   */\n  CircularChart3DPolygonModule.prototype.getNormal = function (transform, vectorPoints) {\n    var normal;\n    if (vectorPoints != null) {\n      normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n      for (var i = 3; i < vectorPoints.length && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n        var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n        var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n        var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n        normal = this.vector.getNormal(v1, v2, v3);\n      }\n    }\n    return normal;\n  };\n  /**\n   * Creates a text element in the context of a circular 3D chart.\n   *\n   * @param {CircularChart3DVector} position - The position of the text.\n   * @param {CircularChart3DLabelElement} element - The text element to be created.\n   * @param {number} xLength - The x value for the text element.\n   * @param {number} yLength - The y value for the text element.\n   * @returns {CircularChart3DPolygon} - Returns the polygon representing the created text element.\n   */\n  CircularChart3DPolygonModule.prototype.createTextElement = function (position, element, xLength, yLength) {\n    var vectorCollection = [];\n    var x = position.x;\n    var y = position.y;\n    var desiredWidth = element.width;\n    var desiredHeight = element.height;\n    vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n    vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n    vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n    return this.text3D(element, vectorCollection);\n  };\n  /**\n   * Creates a 3D polyline by connecting a series of points in 3D space.\n   *\n   * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n   * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polyline.\n   * @returns {CircularChart3DPolygon} - The resulting 3D polyline with the specified circular 3D label element and vertices.\n   */\n  CircularChart3DPolygonModule.prototype.createPolyline = function (points, element) {\n    if (points.length === 2) {\n      var prePoint = points[1];\n      points.push({\n        x: prePoint.x,\n        y: prePoint.y,\n        z: prePoint.z\n      });\n    }\n    return this.polyLine3D(element, points);\n  };\n  /**\n   * Creates a 3D polygon by connecting a series of points in 3D space.\n   *\n   * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polygon.\n   * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n   * @returns {CircularChart3DPolygon} - The resulting 3D polygon with the specified circular 3D label element and vertices.\n   */\n  CircularChart3DPolygonModule.prototype.polyLine3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Creates a 3D text polygon based on the given label element and points.\n   *\n   * @param {CircularChart3DLabelElement} element - The label element associated with the text.\n   * @param {CircularChart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n   * @returns {CircularChart3DPolygon} - Returns the created 3D text polygon.\n   */\n  CircularChart3DPolygonModule.prototype.text3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Draws a polyline on the circular 3D chart panel.\n   *\n   * @param {CircularChart3DPolygon} panel - The polygon panel on which to draw the polyline.\n   * @param {CircularChart3D} chart - The circular 3D chart instance.\n   */\n  CircularChart3DPolygonModule.prototype.drawPolyLine = function (panel, chart) {\n    var transform = circular3DRender.transform;\n    var pathDirection = chart.svg3DRenderer.getStringBuilder();\n    var startPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    pathDirection.append(\"M \" + startPoint.x + \" \" + startPoint.y + \" \");\n    var lineSegment1 = chart.transform3D.toScreen(panel.vectorPoints[1], transform);\n    pathDirection.append(\"L \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n    pathDirection.append(\"M \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n    var lineSegment2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n    pathDirection.append(\"L \" + lineSegment2.x + \" \" + lineSegment2.y + \" \");\n    var direction = pathDirection.toString();\n    var optionsLine = {\n      id: panel.element.id,\n      'stroke-dasharray': panel.element.dashArray,\n      'stroke-width': panel.element.width,\n      stroke: panel.element.stroke,\n      d: direction\n    };\n    var element = chart.renderer.drawPath(optionsLine);\n    appendChildElement(false, chart.groupElement, element, chart.redraw, true, 'x', 'y', null, direction);\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a circular 3D series.\n   *\n   * @param {CircularChart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n   * @param {CircularChart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  CircularChart3DPolygonModule.prototype.drawText = function (panel, chart) {\n    var element = panel.element;\n    var transform = circular3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    var x = actual3DPosition.x;\n    var y = actual3DPosition.y;\n    if (element.tag === 'text') {\n      var options = {\n        'id': element.id,\n        'x': x,\n        'y': y,\n        'fill': element.font.color || element.fill,\n        'font-size': element.font.size,\n        'font-family': element.font.fontFamily || chart.themeStyle.datalabelFont.fontFamily,\n        'font-style': element.font.fontStyle,\n        'font-weight': element.font.fontWeight,\n        'opacity': element.font.opacity,\n        'text-anchor': element.textAnchor,\n        'cursor': 'default',\n        'transform': element.angle ? 'rotate(' + element.angle + ',' + x + ',' + y + ')' : ''\n      };\n      var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n      if (element.id.indexOf('text') > -1) {\n        textElement.setAttribute('aria-hidden', 'true');\n      }\n      chart.groupElement.append(textElement);\n      if (chart.previousID && chart.isTouch) {\n        var previousElement = document.getElementById(chart.previousID);\n        var currentElement = document.getElementById(options.id);\n        if (previousElement && currentElement) {\n          currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n        }\n      }\n      chart.previousID = options.id;\n    } else {\n      var series = element.series;\n      var pointText = element.point.argsData.text;\n      var textOffset = measureText(pointText, element.point.argsData.font, chart.themeStyle.datalabelFont);\n      var padding = 10;\n      var width = textOffset.width + padding + padding;\n      var height = textOffset.height + padding + padding;\n      var location_1 = {\n        x: actual3DPosition.x,\n        y: actual3DPosition.y\n      };\n      var xXalue = location_1.x - padding / 2 + padding / 2;\n      var yValue = location_1.y - padding / 2 - height / padding + padding / 2;\n      var seriesIndex = series.index;\n      this.dataLabelSymbol(seriesIndex, series, element, xXalue, yValue, width, height, chart);\n    }\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a circular 3D series.\n   *\n   * @param {number} seriesIndex - The index of the series to which the data point belongs.\n   * @param {CircularChart3DSeries} series - The circular 3D series containing the data point.\n   * @param {CircularChart3DLabelElement} dataElement - The index of the data point within the series.\n   * @param {number} x - The x-coordinate of the center of the symbol.\n   * @param {number} y - The y-coordinate of the center of the symbol.\n   * @param {number} width - The width of the symbol.\n   * @param {number} height - The height of the symbol.\n   * @param {CircularChart3D} chart - The circular 3D chart containing the series.\n   * @returns {void}\n   */\n  CircularChart3DPolygonModule.prototype.dataLabelSymbol = function (seriesIndex, series, dataElement, x, y, width, height, chart) {\n    var path = 'M' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' z';\n    var transform = '';\n    if (series.dataLabel.enableRotation) {\n      var degree = void 0;\n      var angle = degree = series.dataLabel.angle;\n      if (angle === 0) {\n        var toDegrees = function (angle) {\n          return angle * (180 / Math.PI);\n        };\n        var midAngle = toDegrees(dataElement.point.symbolLocation.angle);\n        if (series.dataLabel.position === 'Outside') {\n          degree = 0;\n        } else if (midAngle >= 90 && midAngle <= 260) {\n          degree = midAngle + 180;\n        } else {\n          degree = midAngle;\n        }\n      } else {\n        degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n      }\n      transform = 'rotate(' + degree + ',' + x + ',' + y + ')';\n    }\n    var rectOptions = {\n      id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-shape-' + dataElement.pointIndex,\n      fill: dataElement.point.argsData.color,\n      'stroke-width': dataElement.point.argsData.border.width,\n      stroke: dataElement.point.argsData.border.color,\n      \"stroke-dasharray\": dataElement.point.argsData.border.dashArray,\n      opacity: 1,\n      visibility: '',\n      transform: transform,\n      d: path\n    };\n    var element = chart.renderer.drawPath(rectOptions);\n    chart.groupElement.append(element);\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(rectOptions.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = rectOptions.id;\n  };\n  /**\n   * Draws a circular 3D polygon on the specified chart.\n   *\n   * @param {CircularChart3DPolygon} panel - The polygon to be drawn.\n   * @param {CircularChart3D} chart - The circular 3D chart on which the polygon is to be drawn.\n   * @returns {void}\n   */\n  CircularChart3DPolygonModule.prototype.draw = function (panel, chart) {\n    if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n      return;\n    }\n    var transform = circular3DRender.transform;\n    var pathDirection = chart.svg3DRenderer.getStringBuilder();\n    var color = panel.fill;\n    var format = chart.svg3DRenderer.checkColorFormat(color);\n    if (!format) {\n      color = colorNameToHex(color);\n    }\n    var figure = {\n      StartPoint: null\n    };\n    if (transform != null) {\n      figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n      pathDirection.append('M' + ' ' + figure.StartPoint.x + ' ' + figure.StartPoint.y + ' ');\n      for (var i = 0; i < panel.vectorPoints.length; i++) {\n        var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n        pathDirection.append('L' + ' ' + lineSegment.x + ' ' + lineSegment.y + ' ');\n      }\n    }\n    var direction = pathDirection.toString();\n    var name = 'Light';\n    var lightCoefficientZ = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1);\n    var lightCoefficientY = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1);\n    var lightCoefficientX = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1);\n    if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n      if (lightCoefficientZ === lightCoefficientX) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else if (lightCoefficientY === lightCoefficientZ || lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ) {\n        name = 'XLight';\n        color = this.applyXLight(color, chart);\n      } else if (lightCoefficientZ < 0) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else {\n        name = 'Light';\n      }\n    }\n    var options = {\n      'id': chart.element.id + '-svg-' + panel.name,\n      'name': name,\n      'fill': color,\n      'stroke': '',\n      'stroke-width': panel.strokeThickness,\n      'opacity': panel.opacity,\n      'd': direction\n    };\n    var element = chart.renderer.drawPath(options);\n    if (panel.text) {\n      element.setAttribute('aria-label', panel.text);\n      element.setAttribute('role', 'img');\n    }\n    appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(options.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = options.id;\n  };\n  /**\n   * Draws text on the specified circular 3D chart panel.\n   *\n   * @param {CircularChart3DPolygon} panel - The circular 3D polygon representing the panel on which the text will be drawn.\n   * @param {CircularChart3D} chart - The circular 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  CircularChart3DPolygonModule.prototype.drawTemplate = function (panel, chart) {\n    var element = panel.element;\n    var transform = circular3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var label = element.label;\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    chart.circularChartDataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.points[label.pointIndex], label.series.points[label.pointIndex].argsData, label.pointIndex, false, actual3DPosition, chart);\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green, and blue components.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  CircularChart3DPolygonModule.prototype.applyXLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green, and blue components with a focus on the Z-axis.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  CircularChart3DPolygonModule.prototype.applyZLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  return CircularChart3DPolygonModule;\n}();\nexport { CircularChart3DPolygonModule };\nvar vector = new CircularChart3DVectorModule(0, 0, 0);\nvar matrixObj = new CircularChart3DMatrix();\nvar bspTreeObj = new CircularChart3DBinaryTreeBuilder();\nvar polygonObj = new CircularChart3DPolygonModule();","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","measureText","appendChildElement","colorNameToHex","CircularChart3DRender","transform","circular3DRender","CircularChart3DVectorModule","pointX","vy","vz","x","y","z","epsilon","isValid","point","isNaN","vector3D","vx","vector3DMinus","v1","v2","vector3DPlus","vector3DMultiply","vector3DAdd","vector3DStarMultiply","value","getLength","vector","sqt","Math","sqrt","getNormal","v3","vector4","vector5","CircularChart3DMatrix","matrixSize","matrix3D","size","matrixData","createArray","isAffine","initialSize","index","getIdentity","getInterval","matrix","j","getMinor","transposed","getMatrixMultiple","getDeterminant","factor","getMatrixVectorMultiple","c","getMatrixMultiplication","matrix1","matrix2","result","k","columnIndex","rowIndex","getMatrix","count","subMatrix","matrixColumn","matrixRow","determinant","submatrix","transformedMatrix","turn","angle","rotatedMatrix","cos","sin","tilt","transposedMatrix","CircularChart3DTransform","toRadial","PI","matrixObj","transform3D","viewingArea","rotation","depth","perspectiveAngle","needUpdate","centeredMatrix","perspective","resultMatrix","viewMatrix","setCenter","width","height","setViewMatrix","updatePerspective","tan","degreeToRadianConverter","abs","toScreen","chartObj","matrixobj","center","CircularChart3DGraphics","prepareView","chart","bspTreeObj","build","tree","groupElement","id","view","panel","MaxValue","eyeVector","drawNode3D","eye","draw3DElement","bspElement","plane","element","tag","polygonObj","drawText","drawPolyLine","drawTemplate","draw","r","vectorPoints","d","front","back","CircularChart3DBinaryTreeBuilder","getNext","vector3DIndexClassification","isCuttingBackPoint","cuttingBackPairIndex","alreadyCutBack","isCuttingFrontPoint","cuttingFrontPairIndex","alreadyCutFront","classifyPoint","polygon","signedDistance","normal","classifyPolygon","refPolygon","classPolygon","points","onBack","onFront","onPlane","polygonValue","len","splitPolygon","backPoint","frontPoint","polyPoints","backPartPoints","frontPartPoints","outputs","inputs","pointB","pointC","sideB","sideC","attributeB","push","vectorValue","direction","intersectionParameter","intersectionPoint","attributeIntersection","backAttribute1","backAttribute2","cuttingBackPoint","alterCuttingBackPairIndex","frontAttribute1","frontAttribute2","cuttingFrontPoint","alterCuttingFrontPairIndex","cutOutBackPolygon","polygon1","polygon3D","cutOutFrontPolygon","polygon2","backPolygon","frontPolygon","initialVertex","currentVertex","currentVertexPair","previousVertexOnBack","nextVertexOnBack","circular3DPolygon","inputPolygons","bspNode","polygonsToLeft","polygonsToRight","currentPolygon","classificationResult","name","CircularChart3DSvgRenderer","getStringBuilder","data","counter","append","text","toString","join","hexToValue","hexColorCode","rgbRegex","test","exec","red","parseInt","green","blue","alpha","options","label","font","document","getElementById","querySelector","createElementNS","textContent","renderer","setElementAttributes","hexColor","color","redValue","greenValue","blueValue","returnColor","hex_1","forEach","val","nr","toUpperCase","checkColorFormat","regex","CircularChart3DPolygonModule","stroke","strokeThickness","opacity","fill","parent","calculateNormal","isSplit","polygonElement","args","_i","vector1","vector2","vector3","length_1","createTextElement","position","xLength","yLength","vectorCollection","desiredWidth","desiredHeight","text3D","createPolyline","prePoint","polyLine3D","pathDirection","svg3DRenderer","startPoint","lineSegment1","lineSegment2","optionsLine","dashArray","drawPath","redraw","actual3DPosition","fontFamily","themeStyle","datalabelFont","fontStyle","fontWeight","textAnchor","textElement","indexOf","setAttribute","previousID","isTouch","previousElement","currentElement","parentNode","insertBefore","nextSibling","series","pointText","argsData","textOffset","padding","location_1","xXalue","yValue","seriesIndex","dataLabelSymbol","dataElement","path","dataLabel","enableRotation","degree","toDegrees","midAngle","symbolLocation","rectOptions","pointIndex","border","visibility","format","figure","StartPoint","lineSegment","lightCoefficientZ","lightCoefficientY","lightCoefficientX","applyZLight","applyXLight","circularChartDataLabel3DModule","createDataLabelTemplate","dataLabelElement","RGB"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/3d-renderer.js"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable no-constant-condition */\n/* eslint-disable no-useless-escape */\n/* eslint-disable prefer-rest-params */\n/* eslint-disable @typescript-eslint/tslint/config */\n/* eslint-disable security/detect-unsafe-regex */\n/* eslint-disable valid-jsdoc */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\n/**\n * Represents a 3D rendering configuration for the EJ 3D rendering engine.\n *\n */\nvar CircularChart3DRender = /** @class */ (function () {\n    function CircularChart3DRender() {\n        this.transform = null; // Chart3DBasicTransform\n    }\n    return CircularChart3DRender;\n}());\nexport { CircularChart3DRender };\nvar circular3DRender = new CircularChart3DRender();\n/**\n * Represents a circular 3D vector in space.\n */\nvar CircularChart3DVectorModule = /** @class */ (function () {\n    /**\n     * Constructs a new Vector3D instance.\n     *\n     * @constructor\n     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n     */\n    function CircularChart3DVectorModule(pointX, vy, vz) {\n        /** The x-coordinate of the vector. */\n        this.x = 0;\n        /** The y-coordinate of the vector. */\n        this.y = 0;\n        /** The z-coordinate of the vector. */\n        this.z = 0;\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.00001;\n        this.x = pointX;\n        this.y = vy || 0;\n        this.z = vz || 0;\n    }\n    /**\n     * Checks if a vector is valid (not NaN for any component).\n     *\n     * @param {CircularChart3DVector} point - The vector to check.\n     * @returns {boolean} - True if the vector is valid, false otherwise.\n     */\n    CircularChart3DVectorModule.prototype.isValid = function (point) {\n        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {CircularChart3DVector} - The new Vector3D instance.\n     */\n    CircularChart3DVectorModule.prototype.vector3D = function (vx, vy, vz) {\n        this.x = vx;\n        this.y = vy;\n        this.z = vz;\n        return { x: this.x, y: this.y, z: this.z };\n    };\n    /**\n     * Subtracts one vector from another and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector to subtract from the first.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DMinus = function (v1, v2) {\n        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    };\n    /**\n     * Adds two vectors and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector to add to the first.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DPlus = function (v1, v2) {\n        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    };\n    /**\n     * Multiplies two vectors using the cross product and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DMultiply = function (v1, v2) {\n        var x = v1.y * v2.z - v2.y * v1.z;\n        var y = v1.z * v2.x - v2.z * v1.x;\n        var z = v1.x * v2.y - v2.x * v1.y;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the dot product of two vectors.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector.\n     * @returns {number} - The dot product.\n     */\n    CircularChart3DVectorModule.prototype.vector3DAdd = function (v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    };\n    /**\n     * Multiplies a vector by a scalar value.\n     *\n     * @param {CircularChart3DVector} v1 - The vector to multiply.\n     * @param {number} value - The scalar value.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DStarMultiply = function (v1, value) {\n        var x = v1.x * value;\n        var y = v1.y * value;\n        var z = v1.z * value;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the length of a vector.\n     *\n     * @param {CircularChart3DVector} vector - The vector to calculate the length of.\n     * @returns {number} - The length of the vector.\n     */\n    CircularChart3DVectorModule.prototype.getLength = function (vector) {\n        var sqt = this.vector3DAdd(vector, vector);\n        return Math.sqrt(sqt);\n    };\n    /**\n     * Calculates the normal vector of a triangle defined by three vectors.\n     *\n     * @param {CircularChart3DVector} v1 - The first vertex of the triangle.\n     * @param {CircularChart3DVector} v2 - The second vertex of the triangle.\n     * @param {CircularChart3DVector} v3 - The third vertex of the triangle.\n     * @returns {CircularChart3DVector} - The normal vector of the triangle.\n     */\n    CircularChart3DVectorModule.prototype.getNormal = function (v1, v2, v3) {\n        var vector4 = this.vector3DMinus(v1, v2);\n        var vector5 = this.vector3DMinus(v3, v2);\n        var n = this.vector3DMultiply(vector4, vector5);\n        var length = this.getLength(n);\n        if (length < this.epsilon) {\n            return this.vector3D(0, 0, 0);\n        }\n        return this.vector3D(n.x / length, n.y / length, n.z / length);\n    };\n    return CircularChart3DVectorModule;\n}());\nexport { CircularChart3DVectorModule };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar CircularChart3DMatrix = /** @class */ (function () {\n    function CircularChart3DMatrix() {\n        /** The size of the matrix, which is set to 4 by default. */\n        this.matrixSize = 4;\n    }\n    /**\n     * Generates a 3D matrix of the specified size.\n     *\n     * @param {number} size - The size of the 3D matrix.\n     * @returns {number[][]} - The generated 3D matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.matrix3D = function (size) {\n        var matrixData = [];\n        for (var i = 0; i < size; i++) {\n            matrixData[i] = this.createArray(size);\n        }\n        return matrixData;\n    };\n    /**\n     * Checks if a matrix is an affine matrix.\n     *\n     * @param {number[][]} matrixData - The matrix to check.\n     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n     */\n    CircularChart3DMatrix.prototype.isAffine = function (matrixData) {\n        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n    };\n    /**\n     * Creates a new array with zeros.\n     *\n     * @param {number} initialSize - The size of the array.\n     * @returns {number[]} - The created array.\n     */\n    CircularChart3DMatrix.prototype.createArray = function (initialSize) {\n        var matrixData = [];\n        for (var index = 0; index < initialSize; ++index) {\n            matrixData[index] = 0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the identity matrix.\n     *\n     * @returns {number[][]} - The identity matrix.\n     */\n    CircularChart3DMatrix.prototype.getIdentity = function () {\n        var matrixData = this.matrix3D(this.matrixSize);\n        for (var i = 0; i < this.matrixSize; i++) {\n            matrixData[i][i] = 1.0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the interval of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix to get the interval for.\n     * @returns {number[][]} - The interval matrix.\n     */\n    CircularChart3DMatrix.prototype.getInterval = function (matrix) {\n        var matrixData = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                matrixData[i][j] = this.getMinor(matrix, i, j);\n            }\n        }\n        matrixData = this.transposed(matrixData);\n        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n        return matrixData;\n    };\n    /**\n     * Multiplies all elements of a matrix by a factor.\n     *\n     * @param {number} factor - The factor to multiply with.\n     * @param {number[][]} matrix - The matrix to multiply.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrixMultiple = function (factor, matrix) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j < matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * factor;\n            }\n        }\n        return matrix;\n    };\n    /**\n     * Multiplies a matrix by a vector.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {CircularChart3DVector} point - The vector to multiply with.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DMatrix.prototype.getMatrixVectorMultiple = function (matrix, point) {\n        var x = matrix[0][0] * point.x +\n            matrix[1][0] * point.y +\n            matrix[2][0] * point.z +\n            matrix[3][0];\n        var y = matrix[0][1] * point.x +\n            matrix[1][1] * point.y +\n            matrix[2][1] * point.z +\n            matrix[3][1];\n        var z = matrix[0][2] * point.x +\n            matrix[1][2] * point.y +\n            matrix[2][2] * point.z +\n            matrix[3][2];\n        if (!this.isAffine(matrix)) {\n            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n            x *= c;\n            y *= c;\n            z *= c;\n        }\n        return { x: x, y: y, z: z };\n    };\n    /**\n     * Multiplies two matrices.\n     *\n     * @param {number[][]} matrix1 - The first matrix.\n     * @param {number[][]} matrix2 - The second matrix.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n        var result = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                var value = 0;\n                for (var k = 0; k < this.matrixSize; k++) {\n                    value += matrix1[k][j] * matrix2[i][k];\n                }\n                result[i][j] = value;\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the minor of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number} - The minor of the matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n    };\n    /**\n     * Gets a submatrix of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number[][]} - The submatrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n        var count = matrix.length - 1;\n        var subMatrix = this.createArray(count);\n        for (var i = 0; i < count; i++) {\n            var matrixColumn = i >= columnIndex ? i + 1 : i;\n            subMatrix[i] = this.createArray(count);\n            for (var j = 0; j < count; j++) {\n                var matrixRow = j >= rowIndex ? j + 1 : j;\n                subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n            }\n        }\n        return subMatrix;\n    };\n    /**\n     * Gets the determinant of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @returns {number} - The determinant of the matrix.\n     */\n    CircularChart3DMatrix.prototype.getDeterminant = function (matrix) {\n        var count = matrix.length;\n        var determinant = 0;\n        if (count < 2) {\n            determinant = matrix[0][0];\n        }\n        else {\n            var k = 1;\n            for (var i = 0; i < count; i++) {\n                var submatrix = this.getMatrix(matrix, i, 0);\n                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n                k = k > 0 ? -1 : 1;\n            }\n        }\n        return determinant;\n    };\n    /**\n     * Transforms a matrix by translation.\n     *\n     * @param {number} x - The x-coordinate of the translation.\n     * @param {number} y - The y-coordinate of the translation.\n     * @param {number} z - The z-coordinate of the translation.\n     * @returns {number[][]} - The transformed matrix.\n     */\n    CircularChart3DMatrix.prototype.transform = function (x, y, z) {\n        var transformedMatrix = this.getIdentity();\n        transformedMatrix[3][0] = x;\n        transformedMatrix[3][1] = y;\n        transformedMatrix[3][2] = z;\n        return transformedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the y-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.turn = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[0][0] = Math.cos(angle);\n        rotatedMatrix[2][0] = -Math.sin(angle);\n        rotatedMatrix[0][2] = Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the x-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    CircularChart3DMatrix.prototype.tilt = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[1][1] = Math.cos(angle);\n        rotatedMatrix[2][1] = Math.sin(angle);\n        rotatedMatrix[1][2] = -Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Transposes a matrix.\n     *\n     * @param {number[][]} matrix3D - The matrix to transpose.\n     * @returns {number[][]} - The transposed matrix.\n     */\n    CircularChart3DMatrix.prototype.transposed = function (matrix3D) {\n        var transposedMatrix = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                transposedMatrix[i][j] = matrix3D[j][i];\n            }\n        }\n        return transposedMatrix;\n    };\n    return CircularChart3DMatrix;\n}());\nexport { CircularChart3DMatrix };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar CircularChart3DTransform = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `ChartTransform` class.\n     */\n    function CircularChart3DTransform() {\n        /** Represents the angle conversion factor from degrees to radians. */\n        this.toRadial = Math.PI / 180;\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n        this.matrixObj = new CircularChart3DMatrix();\n    }\n    /**\n     * Creates a 3D transformation based on the specified size.\n     *\n     * @param {Size} size - The size of the viewing area.\n     * @returns {CircularChart3DBasicTransform} - The 3D transformation.\n     */\n    CircularChart3DTransform.prototype.transform3D = function (size) {\n        return {\n            viewingArea: size,\n            rotation: 0,\n            tilt: 0,\n            depth: 0,\n            perspectiveAngle: 0,\n            needUpdate: true,\n            centeredMatrix: this.matrixObj.getIdentity(),\n            perspective: this.matrixObj.getIdentity(),\n            resultMatrix: this.matrixObj.getIdentity(),\n            viewMatrix: this.matrixObj.getIdentity()\n        };\n    };\n    /**\n     * Applies the specified 3D transformation to the current state.\n     *\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation to apply.\n     * @returns {void} - The 3D transformation.\n     */\n    CircularChart3DTransform.prototype.transform = function (transform) {\n        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n        this.updatePerspective(transform.perspectiveAngle, transform);\n        transform.needUpdate = true;\n    };\n    /**\n     * Updates the perspective matrix based on the specified angle.\n     *\n     * @param {number} angle - The perspective angle.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.updatePerspective = function (angle, transform) {\n        var width = (((transform.viewingArea.width + transform.viewingArea.height) *\n            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);\n        transform.perspective[0][0] = width;\n        transform.perspective[1][1] = width;\n        transform.perspective[2][3] = 1;\n        transform.perspective[3][3] = width;\n    };\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {number} - The angle in radians.\n     * @private\n     */\n    CircularChart3DTransform.prototype.degreeToRadianConverter = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    /**\n     * Transforms a 3D vector to screen coordinates based on the current state.\n     *\n     * @param {CircularChart3DVector} vector3D - The 3D vector to transform.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @param {CircularChart3DMatrix} chartObj - Optional custom matrix object for transformation.\n     * @returns {CircularChart3DLocation} - The screen coordinates.\n     */\n    CircularChart3DTransform.prototype.toScreen = function (vector3D, transform, chartObj) {\n        if (!chartObj) {\n            transform.chartObj = this.matrixObj;\n            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n        }\n        else {\n            this.matrixObj = chartObj;\n            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n        }\n        return { x: vector3D.x, y: vector3D.y };\n    };\n    /**\n     * Sets the view matrix in the transformation state.\n     *\n     * @param {number[][]} matrix - The new view matrix.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.setViewMatrix = function (matrix, transform) {\n        if (transform.viewMatrix === matrix) {\n            return;\n        }\n        transform.viewMatrix = matrix;\n        transform.needUpdate = true;\n    };\n    /**\n     * Calculates the final result matrix based on the current state.\n     *\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @param {CircularChart3DMatrix} matrixobj - Optional custom matrix object for transformation.\n     * @returns {number[][]} - The final result matrix.\n     */\n    CircularChart3DTransform.prototype.result = function (transform, matrixobj) {\n        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n        if (!chartObj) {\n            chartObj = matrixobj;\n        }\n        if (!transform.needUpdate) {\n            return transform.resultMatrix;\n        }\n        var matrixObj = this.matrixObj;\n        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n        transform.needUpdate = false;\n        return transform.resultMatrix;\n    };\n    /**\n     * Sets the center in the transformation state.\n     *\n     * @param {CircularChart3DVector} center - The new center vector.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.setCenter = function (center, transform) {\n        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n        transform.needUpdate = true;\n    };\n    return CircularChart3DTransform;\n}());\nexport { CircularChart3DTransform };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n * @class\n */\nvar CircularChart3DGraphics = /** @class */ (function () {\n    function CircularChart3DGraphics() {\n        /** The vector class. */\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n    }\n    /**\n     * Prepares the view for rendering based on specified parameters.\n     *\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n        if (arguments.length === 0) {\n            bspTreeObj.build(null, chart);\n        }\n        else {\n            if (circular3DRender.transform == null) {\n                circular3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                circular3DRender.transform.viewingArea = size;\n            }\n            if (!circular3DRender.tree) {\n                circular3DRender.tree = [];\n            }\n            circular3DRender.transform.rotation = rotation;\n            circular3DRender.transform.tilt = tilt;\n            circular3DRender.transform.depth = depth;\n            circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(circular3DRender.transform);\n            circular3DRender.tree[chart.groupElement.id] = bspTreeObj.build(null, chart);\n        }\n    };\n    /**\n     * Renders the 3D view on the specified panel element.\n     *\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n        var MaxValue = 32767;\n        if (arguments.length === 2) {\n            if (panel == null) {\n                return;\n            }\n            var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eyeVector, panel, chart);\n        }\n        else {\n            if (panel == null) {\n                return;\n            }\n            if (circular3DRender.transform == null) {\n                circular3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                circular3DRender.transform.viewingArea = size;\n            }\n            circular3DRender.transform.rotation = rotation;\n            circular3DRender.transform.tilt = tilt;\n            circular3DRender.transform.depth = depth;\n            circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(circular3DRender.transform);\n            var eye = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eye, panel, chart);\n        }\n    };\n    /**\n     * Draws a 3D element based on the specified Binary Space Partitioning Node.\n     *\n     * @param {CircularChart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.draw3DElement = function (bspElement, chart) {\n        if (bspElement.plane.element) {\n            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n                polygonObj.drawText(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'polyline') {\n                polygonObj.drawPolyLine(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'template') {\n                polygonObj.drawTemplate(bspElement.plane, chart);\n            }\n        }\n        else {\n            polygonObj.draw(bspElement.plane, chart);\n        }\n    };\n    /**\n     * Draws the 3D nodes starting from the root based on the eye vector.\n     *\n     * @param {CircularChart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n     * @param {CircularChart3DVector} eyeVector - The eye vector.\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n        if (bspElement === null || circular3DRender.transform == null) {\n            return;\n        }\n        while (true) {\n            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(circular3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n            if (r > bspElement.plane.d) {\n                if (bspElement.front != null) {\n                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.back != null) {\n                    bspElement = bspElement.back;\n                    continue;\n                }\n            }\n            else {\n                if (bspElement.back != null) {\n                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.front != null) {\n                    bspElement = bspElement.front;\n                    continue;\n                }\n            }\n            break;\n        }\n    };\n    return CircularChart3DGraphics;\n}());\nexport { CircularChart3DGraphics };\n/**\n * Represents a binary tree builder for 3D polygons in a circular 3D chart.\n *\n */\nvar CircularChart3DBinaryTreeBuilder = /** @class */ (function () {\n    function CircularChart3DBinaryTreeBuilder(chart) {\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.0005;\n        this.chart = chart;\n    }\n    /**\n     * Gets the next index considering the array length and the current index.\n     *\n     * @param {number} index - The current index.\n     * @param {number} count - The length of the array.\n     * @returns {number} - The next index.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.getNext = function (index, count) {\n        if (index >= count) {\n            return index - count;\n        }\n        if (index < 0) {\n            return index + count;\n        }\n        return index;\n    };\n    /**\n     * Creates a PolyAttributes object based on the vector, index, and result.\n     *\n     * @param {CircularChart3DVector} point - The vector representing the point.\n     * @param {number} index - The index of the point.\n     * @param {string} result - The result classification.\n     * @returns {CircularChart3DPolyAttributes} - The created PolyAttributes object.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n        return {\n            index: index,\n            result: result,\n            vector: point,\n            isCuttingBackPoint: false,\n            cuttingBackPairIndex: null,\n            alreadyCutBack: false,\n            isCuttingFrontPoint: false,\n            cuttingFrontPairIndex: null,\n            alreadyCutFront: false\n        };\n    };\n    /**\n     * Classifies a point relative to a polygon.\n     *\n     * @param {CircularChart3DVector} point - The point to classify.\n     * @param {CircularChart3DPolygon} polygon - The polygon for classification.\n     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n        var result = 'OnPlane';\n        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n        if (signedDistance > this.epsilon) {\n            result = 'OnBack';\n        }\n        else if (signedDistance < -this.epsilon) {\n            result = 'OnFront';\n        }\n        return result;\n    };\n    /**\n     * Classifies a polygon relative to another polygon.\n     *\n     * @param {CircularChart3DPolygon} refPolygon - The reference polygon.\n     * @param {CircularChart3DPolygon} classPolygon - The polygon to classify.\n     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n        var result = 'Unknown';\n        var points = classPolygon.points;\n        if (points == null) {\n            return result;\n        }\n        var onBack = 0;\n        var onFront = 0;\n        var onPlane = 0;\n        var normal = refPolygon.normal;\n        var polygonValue = refPolygon.d;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n            if (value > this.epsilon) {\n                onBack++;\n            }\n            else if (value < -this.epsilon) {\n                onFront++;\n            }\n            else {\n                onPlane++;\n            }\n            if (onBack > 0 && onFront > 0) {\n                break;\n            }\n        }\n        if (onPlane === points.length) {\n            result = 'OnPlane';\n        }\n        else if (onFront + onPlane === points.length) {\n            result = 'ToRight';\n        }\n        else if (onBack + onPlane === points.length) {\n            result = 'ToLeft';\n        }\n        else {\n            result = 'Unknown';\n        }\n        return result;\n    };\n    /**\n     * Splits a polygon into two parts based on another polygon.\n     *\n     * @param {CircularChart3DPolygon} splitPolygon - The polygon to split.\n     * @param {CircularChart3DPolygon} refPolygon - The reference polygon for splitting.\n     * @returns {CircularChart3DPolyCollections} - The resulting back and front parts.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n        var backPoint = [];\n        var frontPoint = [];\n        if (splitPolygon.points != null) {\n            var polyPoints = [];\n            var backPartPoints = [];\n            var frontPartPoints = [];\n            var outputs = void 0;\n            var inputs = void 0;\n            var count = splitPolygon.points.length;\n            for (var i = 0; i < count; i++) {\n                var pointB = splitPolygon.points[i];\n                var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n                var sideB = this.classifyPoint(pointB, refPolygon);\n                var sideC = this.classifyPoint(pointC, refPolygon);\n                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n                polyPoints.push(attributeB);\n                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n                    var vectorValue = vector.vector3DMinus(pointB, pointC);\n                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n                    polyPoints.push(attributeIntersection);\n                    backPartPoints.push(attributeIntersection);\n                    frontPartPoints.push(attributeIntersection);\n                }\n            }\n            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n                for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n                    var backAttribute1 = backPartPoints[i];\n                    var backAttribute2 = backPartPoints[i + 1];\n                    backAttribute1.cuttingBackPoint = true;\n                    backAttribute2.cuttingBackPoint = true;\n                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n                    var frontAttribute1 = frontPartPoints[i];\n                    var frontAttribute2 = frontPartPoints[i + 1];\n                    frontAttribute1.cuttingFrontPoint = true;\n                    frontAttribute2.cuttingFrontPoint = true;\n                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n                }\n                for (var i = 0; i < backPartPoints.length - 1; i++) {\n                    var backAttribute1 = backPartPoints[i];\n                    if (backAttribute1.alreadyCutBack) {\n                        continue;\n                    }\n                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n                    if (outputs.length > 2) {\n                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n                        backPoint.push(__assign({}, polygon1));\n                    }\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i++) {\n                    var backAttribute2 = frontPartPoints[i];\n                    if (backAttribute2.alreadyCutFront) {\n                        continue;\n                    }\n                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n                    if (inputs.length > 2) {\n                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n                        frontPoint.push(__assign({}, polygon2));\n                    }\n                }\n            }\n        }\n        else {\n            backPoint.push(splitPolygon);\n            frontPoint.push(splitPolygon);\n        }\n        return { backPolygon: backPoint, frontPolygon: frontPoint };\n    };\n    /**\n     * Cuts out the front part of a polygon based on the PolyAttributes.\n     *\n     * @param {CircularChart3DPolyAttributes[]} polyPoints - The polyAttributes array of the polygon.\n     * @param {CircularChart3DPolyAttributes} initialVertex - The polyAttributes representing the cutting point.\n     * @returns {CircularChart3DVector[]} - The resulting points of the front part.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        while (true) {\n            currentVertex.alreadyCutFront = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n            if (currentVertex.cuttingFrontPoint) {\n                if (!currentVertexPair.alreadyCutFront) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n    };\n    /**\n     * Cuts out the back part of a polygon based on the PolyAttributes.\n     *\n     * @param {CircularChart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {CircularChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {CircularChart3DVector[]} - The resulting points of the back part.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        while (true) {\n            currentVertex.alreadyCutBack = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n            if (currentVertex.cuttingBackPoint) {\n                if (!currentVertexPair.alreadyCutBack) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n    };\n    /**\n     * Builds a binary space partitioning from a list of polygons.\n     *\n     * @param {CircularChart3DPolygon[]} [points] - The list of polygons to build the tree from.\n     * @param {CircularChart3D} [chart] - The circular 3D chart.\n     * @returns {CircularChart3DBspNode} - The root node of the Binary Space Partitioning tree.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.build = function (points, chart) {\n        if (!arguments[0]) {\n            return this.build(chart.circular3DPolygon);\n        }\n        else {\n            var inputPolygons = arguments[0];\n            if (inputPolygons.length < 1) {\n                return null;\n            }\n            var bspNode = { back: null, front: null, plane: null };\n            var plane = inputPolygons[0];\n            bspNode.plane = plane;\n            var polygonsToLeft = [];\n            var polygonsToRight = [];\n            for (var i = 1, len = inputPolygons.length; i < len; i++) {\n                var currentPolygon = inputPolygons[i];\n                if (currentPolygon === plane) {\n                    continue;\n                }\n                var classificationResult = this.classifyPolygon(plane, currentPolygon);\n                switch (classificationResult) {\n                    case 'OnPlane':\n                    case 'ToRight':\n                        polygonsToRight.push(currentPolygon);\n                        break;\n                    case 'ToLeft':\n                        polygonsToLeft.push(currentPolygon);\n                        break;\n                    case 'Unknown':\n                        if (currentPolygon.element) {\n                            polygonsToLeft.push(currentPolygon);\n                        }\n                        else {\n                            var result = this.splitPolygon(currentPolygon, plane);\n                            for (var k = 0; k < result.backPolygon.length; k++) {\n                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                                polygonsToLeft.push(result.backPolygon[k]);\n                            }\n                            for (var j = 0; j < result.frontPolygon.length; j++) {\n                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                                polygonsToRight.push(result.frontPolygon[j]);\n                            }\n                        }\n                        break;\n                }\n            }\n            if (polygonsToLeft.length > 0) {\n                bspNode.back = this.build(polygonsToLeft);\n            }\n            if (polygonsToRight.length > 0) {\n                bspNode.front = this.build(polygonsToRight);\n            }\n            return bspNode;\n        }\n    };\n    return CircularChart3DBinaryTreeBuilder;\n}());\nexport { CircularChart3DBinaryTreeBuilder };\n/**\n * The CircularChart3DSvgRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar CircularChart3DSvgRenderer = /** @class */ (function () {\n    function CircularChart3DSvgRenderer() {\n    }\n    /**\n     * Gets a CircularChart3DStringBuilder instance for constructing strings.\n     *\n     * @returns {CircularChart3DStringBuilder} - The StringBuilder instance.\n     */\n    CircularChart3DSvgRenderer.prototype.getStringBuilder = function () {\n        var data = [];\n        var counter = 0;\n        return {\n            append: function (text) {\n                data[counter++] = text;\n                return this;\n            },\n            toString: function (text) {\n                return data.join(text || '');\n            }\n        };\n    };\n    /**\n     * Parses a hex color code and returns its Red green Blue values.\n     *\n     * @param {string} hexColorCode - The hex color code.\n     * @returns {CircularChart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n     */\n    CircularChart3DSvgRenderer.prototype.hexToValue = function (hexColorCode) {\n        var rgbRegex = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.test(hexColorCode);\n        var result;\n        if (rgbRegex === true) {\n            result = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 10),\n                    green: parseInt(result[2], 10),\n                    blue: parseInt(result[3], 10),\n                    alpha: result[4]\n                }\n                : null;\n        }\n        else {\n            result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 16),\n                    green: parseInt(result[2], 16),\n                    blue: parseInt(result[3], 16)\n                }\n                : null;\n        }\n    };\n    /**\n     * Draws text on an SVG element.\n     *\n     * @param {SVGCanvasAttributes} options - The options for drawing the text.\n     * @param {string | string[]} label - The text label.\n     * @param {FontModel} font - The font settings for the text.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {Element} - The created SVG text element.\n     */\n    CircularChart3DSvgRenderer.prototype.drawText = function (options, label, font, chart) {\n        var text = document.getElementById(options.id) || chart.groupElement.querySelector('#' + options.id);\n        if (text === null) {\n            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        }\n        text.textContent = label;\n        text = chart.renderer.setElementAttributes(options, text);\n        return text;\n    };\n    /**\n     * Converts a CircularChart3DColorFormat object to its corresponding color string.\n     *\n     * @param {CircularChart3DColorFormat} color - The color in CircularChart3DColorFormat.\n     * @returns {string} - The color string representation.\n     */\n    CircularChart3DSvgRenderer.prototype.hexColor = function (color) {\n        var redValue = color.red;\n        var greenValue = color.green;\n        var blueValue = color.blue;\n        if (color.alpha) {\n            var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n            return returnColor;\n        }\n        else {\n            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n            hex_1.forEach(function (val, nr) {\n                if (val.length === 1) {\n                    hex_1[nr] = '0' + val;\n                }\n            });\n            return '#' + hex_1.join('').toUpperCase();\n        }\n    };\n    /**\n     * Checks if a given color string is in a valid format (hex or rgba).\n     *\n     * @param {string} color - The color string to check.\n     * @returns {boolean} - True if the color string is valid, otherwise false.\n     */\n    CircularChart3DSvgRenderer.prototype.checkColorFormat = function (color) {\n        var regex = /(rgba?\\((?:\\d{1,3}[,\\)]){3}(?:\\d+\\.\\d+\\))?)|(^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$)/gmi.test(color);\n        return regex;\n    };\n    return CircularChart3DSvgRenderer;\n}());\nexport { CircularChart3DSvgRenderer };\n/**\n * Represents a 3D polygon in a circular 3D chart.\n *\n */\nvar CircularChart3DPolygonModule = /** @class */ (function () {\n    function CircularChart3DPolygonModule() {\n        this.epsilon = 0.00001;\n        this.normal = { x: 0, y: 0, z: 0 };\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n        this.vectorPoints = [];\n        this.matrixObj = new CircularChart3DMatrix();\n    }\n    /**\n     * Creates a 3D polygon.\n     *\n     * @param {CircularChart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n     * @param {CircularChart3DPolygon} [tag] - Additional information or metadata for the polygon.\n     * @param {number} [index] - An index associated with the polygon.\n     * @param {string} [stroke] - The stroke color of the polygon.\n     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n     * @param {number} [opacity] - The opacity of the polygon.\n     * @param {string} [fill] - The fill color of the polygon.\n     * @param {string} [name] - The name or identifier of the polygon.\n     * @param {Element} [parent] - The parent element to which the polygon belongs.\n     * @param {string} [text] - Additional text associated with the polygon.\n     * @returns {CircularChart3DPolygon} - Returns the created polygon.\n     */\n    CircularChart3DPolygonModule.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n        if (arguments.length === 2) {\n            points = arguments[0];\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var polygon = arguments[1];\n            polygon.normal = this.normal;\n            polygon.points = points;\n            polygon.vectorPoints = this.vectorPoints;\n            polygon.isSplit = true;\n            polygon.d = this.d;\n            return polygon;\n        }\n        else {\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var element = { tag: 'path', parent: parent };\n            var polygon = {\n                normal: this.normal,\n                points: points,\n                vectorPoints: this.vectorPoints,\n                index: index,\n                tag: tag,\n                name: name ? name : null,\n                strokeThickness: strokeThickness,\n                opacity: opacity,\n                fill: fill,\n                d: this.d,\n                text: text ? text : '',\n                polygonElement: element\n            };\n            if (arguments.length !== 1) {\n                polygon.polygonElement = element;\n            }\n            return polygon;\n        }\n    };\n    /**\n     * Calculates the normal vector for a 3D polygon based on the provided points.\n     *\n     * @param {...CircularChart3DVector} args - Variable number of vector3D arguments representing points of the polygon.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.calculateNormal = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length >= 3) {\n            // Relative information of the points\n            var vector1 = args[0];\n            var vector2 = args[1];\n            var vector3 = args[2];\n            var vector4 = this.vector.vector3DMinus(vector1, vector2);\n            var vector5 = this.vector.vector3DMinus(vector3, vector2);\n            var normal = this.vector.vector3DMultiply(vector4, vector5);\n            var length_1 = this.vector.getLength(normal); // Get length of the vector\n            if (length_1 < this.epsilon) {\n                length_1 = 1;\n            }\n            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n            if (args[3]) {\n                args[3].normal = this.normal;\n                args[3].d = this.d;\n            }\n        }\n        else {\n            var points = args[0];\n            this.calculateNormal(points[0], points[1], points[2], arguments[1]);\n            for (var i = 3; (i < points.length) && (this.test()); i++) {\n                this.calculateNormal(points[i], points[0], points[i / 2]);\n            }\n        }\n    };\n    /**\n     * Tests whether the calculated normal vector is valid.\n     *\n     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n     */\n    CircularChart3DPolygonModule.prototype.test = function () {\n        return !this.vector.isValid(this.normal);\n    };\n    /**\n     * Gets the normal vector based on the transformed points using the specified transformation matrix.\n     *\n     * @param {number[][]} transform - The transformation matrix.\n     * @param {CircularChart3DVector[]} [vectorPoints] - The vector points.\n     * @returns {CircularChart3DVector} - Returns the normal vector.\n     * @private\n     */\n    CircularChart3DPolygonModule.prototype.getNormal = function (transform, vectorPoints) {\n        var normal;\n        if (vectorPoints != null) {\n            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n                normal = this.vector.getNormal(v1, v2, v3);\n            }\n        }\n        return normal;\n    };\n    /**\n     * Creates a text element in the context of a circular 3D chart.\n     *\n     * @param {CircularChart3DVector} position - The position of the text.\n     * @param {CircularChart3DLabelElement} element - The text element to be created.\n     * @param {number} xLength - The x value for the text element.\n     * @param {number} yLength - The y value for the text element.\n     * @returns {CircularChart3DPolygon} - Returns the polygon representing the created text element.\n     */\n    CircularChart3DPolygonModule.prototype.createTextElement = function (position, element, xLength, yLength) {\n        var vectorCollection = [];\n        var x = position.x;\n        var y = position.y;\n        var desiredWidth = element.width;\n        var desiredHeight = element.height;\n        vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n        return this.text3D(element, vectorCollection);\n    };\n    /**\n     * Creates a 3D polyline by connecting a series of points in 3D space.\n     *\n     * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n     * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polyline.\n     * @returns {CircularChart3DPolygon} - The resulting 3D polyline with the specified circular 3D label element and vertices.\n     */\n    CircularChart3DPolygonModule.prototype.createPolyline = function (points, element) {\n        if (points.length === 2) {\n            var prePoint = points[1];\n            points.push({ x: prePoint.x, y: prePoint.y, z: prePoint.z });\n        }\n        return this.polyLine3D(element, points);\n    };\n    /**\n     * Creates a 3D polygon by connecting a series of points in 3D space.\n     *\n     * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polygon.\n     * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n     * @returns {CircularChart3DPolygon} - The resulting 3D polygon with the specified circular 3D label element and vertices.\n     */\n    CircularChart3DPolygonModule.prototype.polyLine3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D text polygon based on the given label element and points.\n     *\n     * @param {CircularChart3DLabelElement} element - The label element associated with the text.\n     * @param {CircularChart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n     * @returns {CircularChart3DPolygon} - Returns the created 3D text polygon.\n     */\n    CircularChart3DPolygonModule.prototype.text3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Draws a polyline on the circular 3D chart panel.\n     *\n     * @param {CircularChart3DPolygon} panel - The polygon panel on which to draw the polyline.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     */\n    CircularChart3DPolygonModule.prototype.drawPolyLine = function (panel, chart) {\n        var transform = circular3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var startPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        pathDirection.append(\"M \" + startPoint.x + \" \" + startPoint.y + \" \");\n        var lineSegment1 = chart.transform3D.toScreen(panel.vectorPoints[1], transform);\n        pathDirection.append(\"L \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n        pathDirection.append(\"M \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n        var lineSegment2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n        pathDirection.append(\"L \" + lineSegment2.x + \" \" + lineSegment2.y + \" \");\n        var direction = pathDirection.toString();\n        var optionsLine = {\n            id: panel.element.id,\n            'stroke-dasharray': panel.element.dashArray,\n            'stroke-width': panel.element.width,\n            stroke: panel.element.stroke,\n            d: direction\n        };\n        var element = chart.renderer.drawPath(optionsLine);\n        appendChildElement(false, chart.groupElement, element, chart.redraw, true, 'x', 'y', null, direction);\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a circular 3D series.\n     *\n     * @param {CircularChart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {CircularChart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.drawText = function (panel, chart) {\n        var element = panel.element;\n        var transform = circular3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var x = actual3DPosition.x;\n        var y = actual3DPosition.y;\n        if (element.tag === 'text') {\n            var options = {\n                'id': element.id,\n                'x': x,\n                'y': y,\n                'fill': element.font.color || element.fill,\n                'font-size': element.font.size,\n                'font-family': element.font.fontFamily || chart.themeStyle.datalabelFont.fontFamily,\n                'font-style': element.font.fontStyle,\n                'font-weight': element.font.fontWeight,\n                'opacity': element.font.opacity,\n                'text-anchor': element.textAnchor,\n                'cursor': 'default',\n                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''\n            };\n            var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n            if (element.id.indexOf('text') > -1) {\n                textElement.setAttribute('aria-hidden', 'true');\n            }\n            chart.groupElement.append(textElement);\n            if (chart.previousID && chart.isTouch) {\n                var previousElement = document.getElementById(chart.previousID);\n                var currentElement = document.getElementById(options.id);\n                if (previousElement && currentElement) {\n                    currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n                }\n            }\n            chart.previousID = options.id;\n        }\n        else {\n            var series = element.series;\n            var pointText = element.point.argsData.text;\n            var textOffset = measureText(pointText, element.point.argsData.font, chart.themeStyle.datalabelFont);\n            var padding = 10;\n            var width = textOffset.width + padding + padding;\n            var height = textOffset.height + padding + padding;\n            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };\n            var xXalue = location_1.x - (padding) / 2 + (padding) / 2;\n            var yValue = location_1.y - (padding) / 2 - (height / padding) + (padding) / 2;\n            var seriesIndex = series.index;\n            this.dataLabelSymbol(seriesIndex, series, element, xXalue, yValue, width, height, chart);\n        }\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a circular 3D series.\n     *\n     * @param {number} seriesIndex - The index of the series to which the data point belongs.\n     * @param {CircularChart3DSeries} series - The circular 3D series containing the data point.\n     * @param {CircularChart3DLabelElement} dataElement - The index of the data point within the series.\n     * @param {number} x - The x-coordinate of the center of the symbol.\n     * @param {number} y - The y-coordinate of the center of the symbol.\n     * @param {number} width - The width of the symbol.\n     * @param {number} height - The height of the symbol.\n     * @param {CircularChart3D} chart - The circular 3D chart containing the series.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.dataLabelSymbol = function (seriesIndex, series, dataElement, x, y, width, height, chart) {\n        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +\n            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (-height / 2)) + ' z';\n        var transform = '';\n        if (series.dataLabel.enableRotation) {\n            var degree = void 0;\n            var angle = degree = series.dataLabel.angle;\n            if (angle === 0) {\n                var toDegrees = function (angle) { return angle * (180 / Math.PI); };\n                var midAngle = toDegrees(dataElement.point.symbolLocation.angle);\n                if (series.dataLabel.position === 'Outside') {\n                    degree = 0;\n                }\n                else if (midAngle >= 90 && midAngle <= 260) {\n                    degree = midAngle + 180;\n                }\n                else {\n                    degree = midAngle;\n                }\n            }\n            else {\n                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n            }\n            transform = 'rotate(' + degree + ',' + (x) + ',' + (y) + ')';\n        }\n        var rectOptions = {\n            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-shape-' + dataElement.pointIndex,\n            fill: dataElement.point.argsData.color,\n            'stroke-width': dataElement.point.argsData.border.width,\n            stroke: dataElement.point.argsData.border.color,\n            \"stroke-dasharray\": dataElement.point.argsData.border.dashArray,\n            opacity: 1,\n            visibility: '',\n            transform: transform,\n            d: path\n        };\n        var element = chart.renderer.drawPath(rectOptions);\n        chart.groupElement.append(element);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(rectOptions.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = rectOptions.id;\n    };\n    /**\n     * Draws a circular 3D polygon on the specified chart.\n     *\n     * @param {CircularChart3DPolygon} panel - The polygon to be drawn.\n     * @param {CircularChart3D} chart - The circular 3D chart on which the polygon is to be drawn.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.draw = function (panel, chart) {\n        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n            return;\n        }\n        var transform = circular3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var color = panel.fill;\n        var format = chart.svg3DRenderer.checkColorFormat(color);\n        if (!format) {\n            color = colorNameToHex(color);\n        }\n        var figure = { StartPoint: null };\n        if (transform != null) {\n            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');\n            for (var i = 0; i < panel.vectorPoints.length; i++) {\n                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');\n            }\n        }\n        var direction = pathDirection.toString();\n        var name = 'Light';\n        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));\n        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));\n        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));\n        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n            if (lightCoefficientZ === lightCoefficientX) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {\n                name = 'XLight';\n                color = this.applyXLight(color, chart);\n            }\n            else if (lightCoefficientZ < 0) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else {\n                name = 'Light';\n            }\n        }\n        var options = {\n            'id': chart.element.id + '-svg-' + panel.name,\n            'name': name,\n            'fill': color,\n            'stroke': '',\n            'stroke-width': panel.strokeThickness,\n            'opacity': panel.opacity,\n            'd': direction\n        };\n        var element = chart.renderer.drawPath(options);\n        if (panel.text) {\n            element.setAttribute('aria-label', panel.text);\n            element.setAttribute('role', 'img');\n        }\n        appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(options.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = options.id;\n    };\n    /**\n     * Draws text on the specified circular 3D chart panel.\n     *\n     * @param {CircularChart3DPolygon} panel - The circular 3D polygon representing the panel on which the text will be drawn.\n     * @param {CircularChart3D} chart - The circular 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.drawTemplate = function (panel, chart) {\n        var element = panel.element;\n        var transform = circular3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var label = element.label;\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        chart.circularChartDataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.points[label.pointIndex], label.series.points[label.pointIndex].argsData, label.pointIndex, false, actual3DPosition, chart);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green, and blue components.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    CircularChart3DPolygonModule.prototype.applyXLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green, and blue components with a focus on the Z-axis.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    CircularChart3DPolygonModule.prototype.applyZLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    return CircularChart3DPolygonModule;\n}());\nexport { CircularChart3DPolygonModule };\nvar vector = new CircularChart3DVectorModule(0, 0, 0);\nvar matrixObj = new CircularChart3DMatrix();\nvar bspTreeObj = new CircularChart3DBinaryTreeBuilder();\nvar polygonObj = new CircularChart3DPolygonModule();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}