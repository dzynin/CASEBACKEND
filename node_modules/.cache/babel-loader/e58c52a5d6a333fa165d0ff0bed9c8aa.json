{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\nvar is = require('hast-util-is-element');\nvar findAfter = require('unist-util-find-after');\nmodule.exports = toText;\n\n// Methods.\nvar min = Math.min;\nvar max = Math.max;\n\n// White space codes.\nvar tab = 0x9;\nvar space = 0x20;\nvar zeroWidthSpace = 0x200b;\n\n// Bidi control characters codes.\nvar alm = 0x61c;\nvar ltr = 0x200e;\nvar rtl = 0x200f;\nvar lre = 0x202a;\nvar rle = 0x202b;\nvar pdf = 0x202c;\nvar lro = 0x202d;\nvar rlo = 0x202e;\nvar lri = 0x2066;\nvar rli = 0x2067;\nvar fsi = 0x2068;\nvar pdi = 0x2069;\n\n// Characters.\nvar tabChar = '\\t';\nvar lineFeedChar = '\\n';\nvar spaceChar = ' ';\n\n// Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\nfunction toText(node) {\n  var children = node.children || [];\n  var length = children.length;\n  var block = blockOrCaption(node);\n  var whiteSpace = inferWhiteSpace(node, {});\n  var index = -1;\n  var results;\n  var current;\n  var result;\n  var value;\n  var count;\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    });\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = [];\n\n  // 3.  For each child node node of this element:\n  while (++index < length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    current = innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index === 0 ? block : false,\n      breakAfter: index === length - 1 ? block : is(children[index + 1], 'br')\n    });\n\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(current);\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1;\n  length = results.length;\n  result = [];\n  while (++index < length) {\n    value = results[index];\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) {\n        count = value;\n      }\n    } else if (value !== '') {\n      if (count) {\n        result.push(repeat(lineFeedChar, count));\n      }\n      count = 0;\n      result.push(value);\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('');\n}\n\n// <https://html.spec.whatwg.org/#inner-text-collection-steps>\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options);\n  }\n  if (node.type === 'text') {\n    return [options.whiteSpace === 'normal' ? collectText(node, options) : collectPreText(node, options)];\n  }\n  return [];\n}\n\n// Collect an element.\nfunction collectElement(node, index, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options);\n  var children = node.children || [];\n  var length = children.length;\n  var offset = -1;\n  var items = [];\n  var current;\n  var prefix;\n  var suffix;\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items;\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (is(node, 'br')) {\n    suffix = lineFeedChar;\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = lineFeedChar;\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (is(node, 'p')) {\n    prefix = 2;\n    suffix = 2;\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++offset < length) {\n    current = innerTextCollection(children[offset], offset, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: offset === 0 ? prefix : false,\n      breakAfter: offset === length - 1 ? suffix : is(children[offset + 1], 'br')\n    });\n    items = items.concat(current);\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push(tabChar);\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) {\n    items.unshift(prefix);\n  }\n  if (suffix) {\n    items.push(suffix);\n  }\n  return items;\n}\n\n// 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\nfunction collectText(node, options) {\n  var breakBefore = options.breakBefore;\n  var breakAfter = options.breakAfter;\n  var value = String(node.value);\n  var index = -1;\n  var length = value.length;\n  var lines = [];\n  var result = [];\n  var lineStart;\n  var lineEnd;\n  var line;\n  var nextLine;\n  var queue;\n  lineStart = 0;\n  lineEnd = value.indexOf(lineFeedChar);\n  lineEnd = lineEnd === -1 ? value.length : lineEnd;\n  while (lineEnd !== -1) {\n    line = value.slice(lineStart, lineEnd);\n\n    // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]) as if they were not there.\n    line = removeBidiControlCharacters(line);\n\n    // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    line = trimAndcollapseSpacesAndTabs(line, breakBefore, breakAfter);\n\n    // Add the line.\n    lines.push(line);\n\n    // Stop.\n    if (lineEnd === value.length) {\n      break;\n    }\n    lineStart = lineEnd + 1;\n    lineEnd = value.indexOf(lineFeedChar, lineStart);\n    lineEnd = lineEnd === -1 ? value.length : lineEnd;\n  }\n  index = -1;\n  length = lines.length;\n  queue = '';\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < length) {\n    line = lines[index];\n    nextLine = lines[index + 1] || '';\n\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (line.charCodeAt(line.length - 1) === zeroWidthSpace || nextLine.charCodeAt(0) === zeroWidthSpace) {\n      result.push(line);\n      queue = '';\n      continue;\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    if (line) {\n      if (queue) {\n        result.push(queue);\n      }\n      result.push(line);\n      queue = spaceChar;\n    }\n  }\n  return result.join('');\n}\nfunction collectPreText(node) {\n  return String(node.value);\n}\nfunction removeBidiControlCharacters(value) {\n  var index = -1;\n  var length = value.length;\n  var result = '';\n  while (++index < length) {\n    if (isBidiControlCharacter(value.charCodeAt(index))) {\n      continue;\n    }\n    result += value.charAt(index);\n  }\n  return result;\n}\n\n// 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var start = 0;\n  var end;\n  var length = value.length;\n  var result = [];\n  var char;\n\n  // Move forward past initial white space.\n  while (start <= length) {\n    char = value.charCodeAt(start);\n    if (char !== space && char !== tab) {\n      break;\n    }\n    start++;\n  }\n\n  // If we’re not directly after a segment break, but there was white space,\n  // add an empty value that will be turned into a space.\n  if (start !== 0 && !breakBefore) {\n    result.push('');\n  }\n  end = next(start - 1);\n  while (start < length) {\n    end = end === -1 ? length : end;\n    result.push(value.slice(start, end));\n    start = end;\n    while (start <= length) {\n      char = value.charCodeAt(start);\n      if (char !== space && char !== tab) {\n        break;\n      }\n      start++;\n    }\n\n    // If we reached the end, there was trailing white space, and there’s no\n    // segment break after this node, add an empty value that will be turned\n    // into a space.\n    if (start === length && start !== end && !breakAfter) {\n      result.push('');\n    }\n    end = next(start);\n  }\n  return result.join(' ');\n  function next(index) {\n    var spaceIndex = value.indexOf(spaceChar, index + 1);\n    var tabIndex = value.indexOf(tabChar, index + 1);\n    var fn = spaceIndex === -1 || tabIndex === -1 ? max : min;\n    return fn(spaceIndex, tabIndex);\n  }\n}\n\n// We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {};\n  var inherit = options.whiteSpace || 'normal';\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre';\n    case 'nobr':\n      return 'nowrap';\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre';\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit;\n    case 'textarea':\n      return 'pre-wrap';\n    default:\n      return inherit;\n  }\n}\nfunction isBidiControlCharacter(char) {\n  switch (char) {\n    case alm:\n    case ltr:\n    case rtl:\n    case lre:\n    case rle:\n    case pdf:\n    case lro:\n    case rlo:\n    case lri:\n    case rli:\n    case fsi:\n    case pdi:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction cell(node) {\n  return is(node, ['th', 'td']);\n}\nfunction row(node) {\n  return is(node, ['tr']);\n}\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nfunction blockOrCaption(node) {\n  return is(node, ['caption',\n  // `table-caption`\n  // Page\n  'html', 'body',\n  // Flow content\n  'address', 'blockquote', 'center',\n  // Legacy\n  'dialog', 'div', 'figure', 'figcaption', 'footer', 'form,', 'header', 'hr', 'legend', 'listing',\n  // Legacy\n  'main', 'p', 'plaintext',\n  // Legacy\n  'pre', 'xmp',\n  // Legacy\n  // Sections and headings\n  'article', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup', 'nav', 'section',\n  // Lists\n  'dir',\n  // Legacy\n  'dd', 'dl', 'dt', 'menu', 'ol', 'ul']);\n}\n\n// Note that we don’t need to include void elements here as they don’t have text.\n//\n// See: <https://github.com/wooorm/html-void-elements>\nfunction notRendered(node) {\n  var properties = node.properties || {};\n  return (\n    // List from: <https://html.spec.whatwg.org/#hidden-elements>\n    is(node, ['datalist', 'head', 'noembed', 'noframes', 'rp', 'script', 'style', 'template', 'title',\n    // Act as if we support scripting.\n    'noscript']) ||\n    // Hidden attribute.\n    properties.hidden ||\n    // From: <https://html.spec.whatwg.org/#flow-content-3>\n    is(node, 'dialog') && !properties.open\n  );\n}","map":{"version":3,"names":["repeat","require","is","findAfter","module","exports","toText","min","Math","max","tab","space","zeroWidthSpace","alm","ltr","rtl","lre","rle","pdf","lro","rlo","lri","rli","fsi","pdi","tabChar","lineFeedChar","spaceChar","node","children","length","block","blockOrCaption","whiteSpace","inferWhiteSpace","index","results","current","result","value","count","type","collectText","breakBefore","breakAfter","innerTextCollection","concat","undefined","push","join","parent","options","collectElement","collectPreText","offset","items","prefix","suffix","notRendered","row","cell","unshift","String","lines","lineStart","lineEnd","line","nextLine","queue","indexOf","slice","removeBidiControlCharacters","trimAndcollapseSpacesAndTabs","charCodeAt","isBidiControlCharacter","charAt","start","end","char","next","spaceIndex","tabIndex","fn","props","properties","inherit","tagName","wrap","noWrap","hidden","open"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/hast-util-to-text/index.js"],"sourcesContent":["'use strict'\n\nvar repeat = require('repeat-string')\nvar is = require('hast-util-is-element')\nvar findAfter = require('unist-util-find-after')\n\nmodule.exports = toText\n\n// Methods.\nvar min = Math.min\nvar max = Math.max\n\n// White space codes.\nvar tab = 0x9\nvar space = 0x20\nvar zeroWidthSpace = 0x200b\n\n// Bidi control characters codes.\nvar alm = 0x61c\nvar ltr = 0x200e\nvar rtl = 0x200f\nvar lre = 0x202a\nvar rle = 0x202b\nvar pdf = 0x202c\nvar lro = 0x202d\nvar rlo = 0x202e\nvar lri = 0x2066\nvar rli = 0x2067\nvar fsi = 0x2068\nvar pdi = 0x2069\n\n// Characters.\nvar tabChar = '\\t'\nvar lineFeedChar = '\\n'\nvar spaceChar = ' '\n\n// Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\nfunction toText(node) {\n  var children = node.children || []\n  var length = children.length\n  var block = blockOrCaption(node)\n  var whiteSpace = inferWhiteSpace(node, {})\n  var index = -1\n  var results\n  var current\n  var result\n  var value\n  var count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    })\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    current = innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index === 0 ? block : false,\n      breakAfter: index === length - 1 ? block : is(children[index + 1], 'br')\n    })\n\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(current)\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  length = results.length\n  result = []\n\n  while (++index < length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) {\n        count = value\n      }\n    } else if (value !== '') {\n      if (count) {\n        result.push(repeat(lineFeedChar, count))\n      }\n\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n// <https://html.spec.whatwg.org/#inner-text-collection-steps>\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whiteSpace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node, options)\n    ]\n  }\n\n  return []\n}\n\n// Collect an element.\nfunction collectElement(node, index, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options)\n  var children = node.children || []\n  var length = children.length\n  var offset = -1\n  var items = []\n  var current\n  var prefix\n  var suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (is(node, 'br')) {\n    suffix = lineFeedChar\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = lineFeedChar\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (is(node, 'p')) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++offset < length) {\n    current = innerTextCollection(children[offset], offset, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: offset === 0 ? prefix : false,\n      breakAfter:\n        offset === length - 1 ? suffix : is(children[offset + 1], 'br')\n    })\n\n    items = items.concat(current)\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push(tabChar)\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) {\n    items.unshift(prefix)\n  }\n\n  if (suffix) {\n    items.push(suffix)\n  }\n\n  return items\n}\n\n// 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\nfunction collectText(node, options) {\n  var breakBefore = options.breakBefore\n  var breakAfter = options.breakAfter\n  var value = String(node.value)\n  var index = -1\n  var length = value.length\n  var lines = []\n  var result = []\n  var lineStart\n  var lineEnd\n  var line\n  var nextLine\n  var queue\n\n  lineStart = 0\n  lineEnd = value.indexOf(lineFeedChar)\n  lineEnd = lineEnd === -1 ? value.length : lineEnd\n\n  while (lineEnd !== -1) {\n    line = value.slice(lineStart, lineEnd)\n\n    // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]) as if they were not there.\n    line = removeBidiControlCharacters(line)\n\n    // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    line = trimAndcollapseSpacesAndTabs(line, breakBefore, breakAfter)\n\n    // Add the line.\n    lines.push(line)\n\n    // Stop.\n    if (lineEnd === value.length) {\n      break\n    }\n\n    lineStart = lineEnd + 1\n    lineEnd = value.indexOf(lineFeedChar, lineStart)\n    lineEnd = lineEnd === -1 ? value.length : lineEnd\n  }\n\n  index = -1\n  length = lines.length\n  queue = ''\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < length) {\n    line = lines[index]\n    nextLine = lines[index + 1] || ''\n\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      line.charCodeAt(line.length - 1) === zeroWidthSpace ||\n      nextLine.charCodeAt(0) === zeroWidthSpace\n    ) {\n      result.push(line)\n      queue = ''\n      continue\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    if (line) {\n      if (queue) {\n        result.push(queue)\n      }\n\n      result.push(line)\n      queue = spaceChar\n    }\n  }\n\n  return result.join('')\n}\n\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\nfunction removeBidiControlCharacters(value) {\n  var index = -1\n  var length = value.length\n  var result = ''\n\n  while (++index < length) {\n    if (isBidiControlCharacter(value.charCodeAt(index))) {\n      continue\n    }\n\n    result += value.charAt(index)\n  }\n\n  return result\n}\n\n// 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var start = 0\n  var end\n  var length = value.length\n  var result = []\n  var char\n\n  // Move forward past initial white space.\n  while (start <= length) {\n    char = value.charCodeAt(start)\n\n    if (char !== space && char !== tab) {\n      break\n    }\n\n    start++\n  }\n\n  // If we’re not directly after a segment break, but there was white space,\n  // add an empty value that will be turned into a space.\n  if (start !== 0 && !breakBefore) {\n    result.push('')\n  }\n\n  end = next(start - 1)\n\n  while (start < length) {\n    end = end === -1 ? length : end\n    result.push(value.slice(start, end))\n    start = end\n\n    while (start <= length) {\n      char = value.charCodeAt(start)\n\n      if (char !== space && char !== tab) {\n        break\n      }\n\n      start++\n    }\n\n    // If we reached the end, there was trailing white space, and there’s no\n    // segment break after this node, add an empty value that will be turned\n    // into a space.\n    if (start === length && start !== end && !breakAfter) {\n      result.push('')\n    }\n\n    end = next(start)\n  }\n\n  return result.join(' ')\n\n  function next(index) {\n    var spaceIndex = value.indexOf(spaceChar, index + 1)\n    var tabIndex = value.indexOf(tabChar, index + 1)\n    var fn = spaceIndex === -1 || tabIndex === -1 ? max : min\n    return fn(spaceIndex, tabIndex)\n  }\n}\n\n// We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {}\n  var inherit = options.whiteSpace || 'normal'\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre'\n    case 'nobr':\n      return 'nowrap'\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre'\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit\n    case 'textarea':\n      return 'pre-wrap'\n    default:\n      return inherit\n  }\n}\n\nfunction isBidiControlCharacter(char) {\n  switch (char) {\n    case alm:\n    case ltr:\n    case rtl:\n    case lre:\n    case rle:\n    case pdf:\n    case lro:\n    case rlo:\n    case lri:\n    case rli:\n    case fsi:\n    case pdi:\n      return true\n    default:\n      return false\n  }\n}\n\nfunction cell(node) {\n  return is(node, ['th', 'td'])\n}\n\nfunction row(node) {\n  return is(node, ['tr'])\n}\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nfunction blockOrCaption(node) {\n  return is(node, [\n    'caption', // `table-caption`\n    // Page\n    'html',\n    'body',\n    // Flow content\n    'address',\n    'blockquote',\n    'center', // Legacy\n    'dialog',\n    'div',\n    'figure',\n    'figcaption',\n    'footer',\n    'form,',\n    'header',\n    'hr',\n    'legend',\n    'listing', // Legacy\n    'main',\n    'p',\n    'plaintext', // Legacy\n    'pre',\n    'xmp', // Legacy\n    // Sections and headings\n    'article',\n    'aside',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'hgroup',\n    'nav',\n    'section',\n    // Lists\n    'dir', // Legacy\n    'dd',\n    'dl',\n    'dt',\n    'menu',\n    'ol',\n    'ul'\n  ])\n}\n\n// Note that we don’t need to include void elements here as they don’t have text.\n//\n// See: <https://github.com/wooorm/html-void-elements>\nfunction notRendered(node) {\n  var properties = node.properties || {}\n\n  return (\n    // List from: <https://html.spec.whatwg.org/#hidden-elements>\n    is(node, [\n      'datalist',\n      'head',\n      'noembed',\n      'noframes',\n      'rp',\n      'script',\n      'style',\n      'template',\n      'title',\n      // Act as if we support scripting.\n      'noscript'\n    ]) ||\n    // Hidden attribute.\n    properties.hidden ||\n    // From: <https://html.spec.whatwg.org/#flow-content-3>\n    (is(node, 'dialog') && !properties.open)\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}