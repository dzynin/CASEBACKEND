{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nclass LocationInfoParserMixin extends Mixin {\n  constructor(parser) {\n    super(parser);\n    this.parser = parser;\n    this.treeAdapter = this.parser.treeAdapter;\n    this.posTracker = null;\n    this.lastStartTagToken = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n  }\n  _setStartLocation(element) {\n    let loc = null;\n    if (this.lastStartTagToken) {\n      loc = Object.assign({}, this.lastStartTagToken.location);\n      loc.startTag = this.lastStartTagToken.location;\n    }\n    this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n  }\n  _setEndLocation(element, closingToken) {\n    const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n    if (loc) {\n      if (closingToken.location) {\n        const ctLoc = closingToken.location;\n        const tn = this.treeAdapter.getTagName(element);\n\n        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n        const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n        if (isClosingEndTag) {\n          loc.endTag = Object.assign({}, ctLoc);\n          loc.endLine = ctLoc.endLine;\n          loc.endCol = ctLoc.endCol;\n          loc.endOffset = ctLoc.endOffset;\n        } else {\n          loc.endLine = ctLoc.startLine;\n          loc.endCol = ctLoc.startCol;\n          loc.endOffset = ctLoc.startOffset;\n        }\n      }\n    }\n  }\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      _bootstrap(document, fragmentContext) {\n        orig._bootstrap.call(this, document, fragmentContext);\n        mxn.lastStartTagToken = null;\n        mxn.lastFosterParentingLocation = null;\n        mxn.currentToken = null;\n        const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        mxn.posTracker = tokenizerMixin.posTracker;\n        Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n          onItemPop: function (element) {\n            mxn._setEndLocation(element, mxn.currentToken);\n          }\n        });\n      },\n      _runParsingLoop(scriptHandler) {\n        orig._runParsingLoop.call(this, scriptHandler);\n\n        // NOTE: generate location info for elements\n        // that remains on open element stack\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n        }\n      },\n      //Token processing\n      _processTokenInForeignContent(token) {\n        mxn.currentToken = token;\n        orig._processTokenInForeignContent.call(this, token);\n      },\n      _processToken(token) {\n        mxn.currentToken = token;\n        orig._processToken.call(this, token);\n\n        //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n        //their end location explicitly.\n        const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n        if (requireExplicitUpdate) {\n          for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const element = this.openElements.items[i];\n            if (this.treeAdapter.getTagName(element) === token.tagName) {\n              mxn._setEndLocation(element, token);\n              break;\n            }\n          }\n        }\n      },\n      //Doctype\n      _setDocumentType(token) {\n        orig._setDocumentType.call(this, token);\n        const documentChildren = this.treeAdapter.getChildNodes(this.document);\n        const cnLength = documentChildren.length;\n        for (let i = 0; i < cnLength; i++) {\n          const node = documentChildren[i];\n          if (this.treeAdapter.isDocumentTypeNode(node)) {\n            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n            break;\n          }\n        }\n      },\n      //Elements\n      _attachElementToTree(element) {\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n        //So we will use token location stored in this methods for the element.\n        mxn._setStartLocation(element);\n        mxn.lastStartTagToken = null;\n        orig._attachElementToTree.call(this, element);\n      },\n      _appendElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n        orig._appendElement.call(this, token, namespaceURI);\n      },\n      _insertElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n        orig._insertElement.call(this, token, namespaceURI);\n      },\n      _insertTemplate(token) {\n        mxn.lastStartTagToken = token;\n        orig._insertTemplate.call(this, token);\n        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n      },\n      _insertFakeRootElement() {\n        orig._insertFakeRootElement.call(this);\n        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n      },\n      //Comments\n      _appendCommentNode(token, parent) {\n        orig._appendCommentNode.call(this, token, parent);\n        const children = this.treeAdapter.getChildNodes(parent);\n        const commentNode = children[children.length - 1];\n        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n      },\n      //Text\n      _findFosterParentingLocation() {\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\n        //in case of foster parenting\n        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n        return mxn.lastFosterParentingLocation;\n      },\n      _insertCharacters(token) {\n        orig._insertCharacters.call(this, token);\n        const hasFosterParent = this._shouldFosterParentOnInsertion();\n        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n        const siblings = this.treeAdapter.getChildNodes(parent);\n        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n        const textNode = siblings[textNodeIdx];\n\n        //NOTE: if we have location assigned by another token, then just update end position\n        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n        if (tnLoc) {\n          tnLoc.endLine = token.location.endLine;\n          tnLoc.endCol = token.location.endCol;\n          tnLoc.endOffset = token.location.endOffset;\n        } else {\n          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n        }\n      }\n    };\n  }\n}\nmodule.exports = LocationInfoParserMixin;","map":{"version":3,"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","LocationInfoOpenElementStackMixin","HTML","$","TAG_NAMES","LocationInfoParserMixin","constructor","parser","treeAdapter","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","_setStartLocation","element","loc","Object","assign","location","startTag","setNodeSourceCodeLocation","_setEndLocation","closingToken","getNodeSourceCodeLocation","ctLoc","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endTag","endLine","endCol","endOffset","startLine","startCol","startOffset","_getOverriddenMethods","mxn","orig","_bootstrap","document","fragmentContext","call","tokenizerMixin","install","tokenizer","openElements","onItemPop","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode","tnLoc","module","exports"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n                if (isClosingEndTag) {\n                    loc.endTag = Object.assign({}, ctLoc);\n                    loc.endLine = ctLoc.endLine;\n                    loc.endCol = ctLoc.endCol;\n                    loc.endOffset = ctLoc.endOffset;\n                } else {\n                    loc.endLine = ctLoc.startLine;\n                    loc.endCol = ctLoc.startCol;\n                    loc.endOffset = ctLoc.startOffset;\n                }\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    tnLoc.endLine = token.location.endLine;\n                    tnLoc.endCol = token.location.endCol;\n                    tnLoc.endOffset = token.location.endOffset;\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}