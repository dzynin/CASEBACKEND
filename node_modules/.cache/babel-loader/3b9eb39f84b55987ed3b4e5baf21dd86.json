{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\n\nvar is = require('hast-util-is-element');\n\nvar findAfter = require('unist-util-find-after');\n\nmodule.exports = toText; // Methods.\n\nvar min = Math.min;\nvar max = Math.max; // White space codes.\n\nvar tab = 0x9;\nvar space = 0x20;\nvar zeroWidthSpace = 0x200b; // Bidi control characters codes.\n\nvar alm = 0x61c;\nvar ltr = 0x200e;\nvar rtl = 0x200f;\nvar lre = 0x202a;\nvar rle = 0x202b;\nvar pdf = 0x202c;\nvar lro = 0x202d;\nvar rlo = 0x202e;\nvar lri = 0x2066;\nvar rli = 0x2067;\nvar fsi = 0x2068;\nvar pdi = 0x2069; // Characters.\n\nvar tabChar = '\\t';\nvar lineFeedChar = '\\n';\nvar spaceChar = ' '; // Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\n\nfunction toText(node) {\n  var children = node.children || [];\n  var length = children.length;\n  var block = blockOrCaption(node);\n  var whiteSpace = inferWhiteSpace(node, {});\n  var index = -1;\n  var results;\n  var current;\n  var result;\n  var value;\n  var count; // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    });\n  } // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n  // 2.  Let results be a new empty list.\n\n\n  results = []; // 3.  For each child node node of this element:\n\n  while (++index < length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    current = innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index === 0 ? block : false,\n      breakAfter: index === length - 1 ? block : is(children[index + 1], 'br')\n    }); // 3.2. For each item item in current, append item to results.\n\n    results = results.concat(current);\n  } // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n\n\n  index = -1;\n  length = results.length;\n  result = [];\n\n  while (++index < length) {\n    value = results[index];\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) {\n        count = value;\n      }\n    } else if (value !== '') {\n      if (count) {\n        result.push(repeat(lineFeedChar, count));\n      }\n\n      count = 0;\n      result.push(value);\n    }\n  } // 7.  Return the concatenation of the string items in results.\n\n\n  return result.join('');\n} // <https://html.spec.whatwg.org/#inner-text-collection-steps>\n\n\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options);\n  }\n\n  if (node.type === 'text') {\n    return [options.whiteSpace === 'normal' ? collectText(node, options) : collectPreText(node, options)];\n  }\n\n  return [];\n} // Collect an element.\n\n\nfunction collectElement(node, index, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options);\n  var children = node.children || [];\n  var length = children.length;\n  var offset = -1;\n  var items = [];\n  var current;\n  var prefix;\n  var suffix; // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n\n  if (notRendered(node)) {\n    return items;\n  } // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n  // See `collectText` for step 4.\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n\n\n  if (is(node, 'br')) {\n    suffix = lineFeedChar;\n  } // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n      suffix = lineFeedChar;\n    } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n    //     at the beginning and end of items.\n    else if (is(node, 'p')) {\n        prefix = 2;\n        suffix = 2;\n      } // 9.  If node’s used value of `display` is block-level or `table-caption`,\n      //     then append 1 (a required line break count) at the beginning and end of\n      //     items.\n      else if (blockOrCaption(node)) {\n          prefix = 1;\n          suffix = 1;\n        } // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n\n\n  while (++offset < length) {\n    current = innerTextCollection(children[offset], offset, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: offset === 0 ? prefix : false,\n      breakAfter: offset === length - 1 ? suffix : is(children[offset + 1], 'br')\n    });\n    items = items.concat(current);\n  } // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n\n\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push(tabChar);\n  } // Add the pre- and suffix.\n\n\n  if (prefix) {\n    items.unshift(prefix);\n  }\n\n  if (suffix) {\n    items.push(suffix);\n  }\n\n  return items;\n} // 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n\n\nfunction collectText(node, options) {\n  var breakBefore = options.breakBefore;\n  var breakAfter = options.breakAfter;\n  var value = String(node.value);\n  var index = -1;\n  var length = value.length;\n  var lines = [];\n  var result = [];\n  var lineStart;\n  var lineEnd;\n  var line;\n  var nextLine;\n  var queue;\n  lineStart = 0;\n  lineEnd = value.indexOf(lineFeedChar);\n  lineEnd = lineEnd === -1 ? value.length : lineEnd;\n\n  while (lineEnd !== -1) {\n    line = value.slice(lineStart, lineEnd); // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]) as if they were not there.\n\n    line = removeBidiControlCharacters(line); // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n\n    line = trimAndcollapseSpacesAndTabs(line, breakBefore, breakAfter); // Add the line.\n\n    lines.push(line); // Stop.\n\n    if (lineEnd === value.length) {\n      break;\n    }\n\n    lineStart = lineEnd + 1;\n    lineEnd = value.indexOf(lineFeedChar, lineStart);\n    lineEnd = lineEnd === -1 ? value.length : lineEnd;\n  }\n\n  index = -1;\n  length = lines.length;\n  queue = ''; // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n\n  while (++index < length) {\n    line = lines[index];\n    nextLine = lines[index + 1] || ''; // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n\n    if (line.charCodeAt(line.length - 1) === zeroWidthSpace || nextLine.charCodeAt(0) === zeroWidthSpace) {\n      result.push(line);\n      queue = '';\n      continue;\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n\n\n    if (line) {\n      if (queue) {\n        result.push(queue);\n      }\n\n      result.push(line);\n      queue = spaceChar;\n    }\n  }\n\n  return result.join('');\n}\n\nfunction collectPreText(node) {\n  return String(node.value);\n}\n\nfunction removeBidiControlCharacters(value) {\n  var index = -1;\n  var length = value.length;\n  var result = '';\n\n  while (++index < length) {\n    if (isBidiControlCharacter(value.charCodeAt(index))) {\n      continue;\n    }\n\n    result += value.charAt(index);\n  }\n\n  return result;\n} // 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\n\n\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var start = 0;\n  var end;\n  var length = value.length;\n  var result = [];\n  var char; // Move forward past initial white space.\n\n  while (start <= length) {\n    char = value.charCodeAt(start);\n\n    if (char !== space && char !== tab) {\n      break;\n    }\n\n    start++;\n  } // If we’re not directly after a segment break, but there was white space,\n  // add an empty value that will be turned into a space.\n\n\n  if (start !== 0 && !breakBefore) {\n    result.push('');\n  }\n\n  end = next(start - 1);\n\n  while (start < length) {\n    end = end === -1 ? length : end;\n    result.push(value.slice(start, end));\n    start = end;\n\n    while (start <= length) {\n      char = value.charCodeAt(start);\n\n      if (char !== space && char !== tab) {\n        break;\n      }\n\n      start++;\n    } // If we reached the end, there was trailing white space, and there’s no\n    // segment break after this node, add an empty value that will be turned\n    // into a space.\n\n\n    if (start === length && start !== end && !breakAfter) {\n      result.push('');\n    }\n\n    end = next(start);\n  }\n\n  return result.join(' ');\n\n  function next(index) {\n    var spaceIndex = value.indexOf(spaceChar, index + 1);\n    var tabIndex = value.indexOf(tabChar, index + 1);\n    var fn = spaceIndex === -1 || tabIndex === -1 ? max : min;\n    return fn(spaceIndex, tabIndex);\n  }\n} // We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n\n\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {};\n  var inherit = options.whiteSpace || 'normal';\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre';\n\n    case 'nobr':\n      return 'nowrap';\n\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre';\n\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit;\n\n    case 'textarea':\n      return 'pre-wrap';\n\n    default:\n      return inherit;\n  }\n}\n\nfunction isBidiControlCharacter(char) {\n  switch (char) {\n    case alm:\n    case ltr:\n    case rtl:\n    case lre:\n    case rle:\n    case pdf:\n    case lro:\n    case rlo:\n    case lri:\n    case rli:\n    case fsi:\n    case pdi:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction cell(node) {\n  return is(node, ['th', 'td']);\n}\n\nfunction row(node) {\n  return is(node, ['tr']);\n} // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\n\nfunction blockOrCaption(node) {\n  return is(node, ['caption', // `table-caption`\n  // Page\n  'html', 'body', // Flow content\n  'address', 'blockquote', 'center', // Legacy\n  'dialog', 'div', 'figure', 'figcaption', 'footer', 'form,', 'header', 'hr', 'legend', 'listing', // Legacy\n  'main', 'p', 'plaintext', // Legacy\n  'pre', 'xmp', // Legacy\n  // Sections and headings\n  'article', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup', 'nav', 'section', // Lists\n  'dir', // Legacy\n  'dd', 'dl', 'dt', 'menu', 'ol', 'ul']);\n} // Note that we don’t need to include void elements here as they don’t have text.\n//\n// See: <https://github.com/wooorm/html-void-elements>\n\n\nfunction notRendered(node) {\n  var properties = node.properties || {};\n  return (// List from: <https://html.spec.whatwg.org/#hidden-elements>\n    is(node, ['datalist', 'head', 'noembed', 'noframes', 'rp', 'script', 'style', 'template', 'title', // Act as if we support scripting.\n    'noscript']) || // Hidden attribute.\n    properties.hidden || // From: <https://html.spec.whatwg.org/#flow-content-3>\n    is(node, 'dialog') && !properties.open\n  );\n}","map":{"version":3,"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONT/gptversion/CASEFRONT/node_modules/hast-util-to-text/index.js"],"names":["repeat","require","is","findAfter","module","exports","toText","min","Math","max","tab","space","zeroWidthSpace","alm","ltr","rtl","lre","rle","pdf","lro","rlo","lri","rli","fsi","pdi","tabChar","lineFeedChar","spaceChar","node","children","length","block","blockOrCaption","whiteSpace","inferWhiteSpace","index","results","current","result","value","count","type","collectText","breakBefore","breakAfter","innerTextCollection","concat","undefined","push","join","parent","options","collectElement","collectPreText","offset","items","prefix","suffix","notRendered","row","cell","unshift","String","lines","lineStart","lineEnd","line","nextLine","queue","indexOf","slice","removeBidiControlCharacters","trimAndcollapseSpacesAndTabs","charCodeAt","isBidiControlCharacter","charAt","start","end","char","next","spaceIndex","tabIndex","fn","props","properties","inherit","tagName","wrap","noWrap","hidden","open"],"mappings":"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","sourcesContent":["'use strict'\n\nvar repeat = require('repeat-string')\nvar is = require('hast-util-is-element')\nvar findAfter = require('unist-util-find-after')\n\nmodule.exports = toText\n\n// Methods.\nvar min = Math.min\nvar max = Math.max\n\n// White space codes.\nvar tab = 0x9\nvar space = 0x20\nvar zeroWidthSpace = 0x200b\n\n// Bidi control characters codes.\nvar alm = 0x61c\nvar ltr = 0x200e\nvar rtl = 0x200f\nvar lre = 0x202a\nvar rle = 0x202b\nvar pdf = 0x202c\nvar lro = 0x202d\nvar rlo = 0x202e\nvar lri = 0x2066\nvar rli = 0x2067\nvar fsi = 0x2068\nvar pdi = 0x2069\n\n// Characters.\nvar tabChar = '\\t'\nvar lineFeedChar = '\\n'\nvar spaceChar = ' '\n\n// Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\nfunction toText(node) {\n  var children = node.children || []\n  var length = children.length\n  var block = blockOrCaption(node)\n  var whiteSpace = inferWhiteSpace(node, {})\n  var index = -1\n  var results\n  var current\n  var result\n  var value\n  var count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    })\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    current = innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index === 0 ? block : false,\n      breakAfter: index === length - 1 ? block : is(children[index + 1], 'br')\n    })\n\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(current)\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  length = results.length\n  result = []\n\n  while (++index < length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) {\n        count = value\n      }\n    } else if (value !== '') {\n      if (count) {\n        result.push(repeat(lineFeedChar, count))\n      }\n\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n// <https://html.spec.whatwg.org/#inner-text-collection-steps>\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whiteSpace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node, options)\n    ]\n  }\n\n  return []\n}\n\n// Collect an element.\nfunction collectElement(node, index, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options)\n  var children = node.children || []\n  var length = children.length\n  var offset = -1\n  var items = []\n  var current\n  var prefix\n  var suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (is(node, 'br')) {\n    suffix = lineFeedChar\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = lineFeedChar\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (is(node, 'p')) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++offset < length) {\n    current = innerTextCollection(children[offset], offset, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: offset === 0 ? prefix : false,\n      breakAfter:\n        offset === length - 1 ? suffix : is(children[offset + 1], 'br')\n    })\n\n    items = items.concat(current)\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push(tabChar)\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) {\n    items.unshift(prefix)\n  }\n\n  if (suffix) {\n    items.push(suffix)\n  }\n\n  return items\n}\n\n// 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\nfunction collectText(node, options) {\n  var breakBefore = options.breakBefore\n  var breakAfter = options.breakAfter\n  var value = String(node.value)\n  var index = -1\n  var length = value.length\n  var lines = []\n  var result = []\n  var lineStart\n  var lineEnd\n  var line\n  var nextLine\n  var queue\n\n  lineStart = 0\n  lineEnd = value.indexOf(lineFeedChar)\n  lineEnd = lineEnd === -1 ? value.length : lineEnd\n\n  while (lineEnd !== -1) {\n    line = value.slice(lineStart, lineEnd)\n\n    // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]) as if they were not there.\n    line = removeBidiControlCharacters(line)\n\n    // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    line = trimAndcollapseSpacesAndTabs(line, breakBefore, breakAfter)\n\n    // Add the line.\n    lines.push(line)\n\n    // Stop.\n    if (lineEnd === value.length) {\n      break\n    }\n\n    lineStart = lineEnd + 1\n    lineEnd = value.indexOf(lineFeedChar, lineStart)\n    lineEnd = lineEnd === -1 ? value.length : lineEnd\n  }\n\n  index = -1\n  length = lines.length\n  queue = ''\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < length) {\n    line = lines[index]\n    nextLine = lines[index + 1] || ''\n\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      line.charCodeAt(line.length - 1) === zeroWidthSpace ||\n      nextLine.charCodeAt(0) === zeroWidthSpace\n    ) {\n      result.push(line)\n      queue = ''\n      continue\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    if (line) {\n      if (queue) {\n        result.push(queue)\n      }\n\n      result.push(line)\n      queue = spaceChar\n    }\n  }\n\n  return result.join('')\n}\n\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\nfunction removeBidiControlCharacters(value) {\n  var index = -1\n  var length = value.length\n  var result = ''\n\n  while (++index < length) {\n    if (isBidiControlCharacter(value.charCodeAt(index))) {\n      continue\n    }\n\n    result += value.charAt(index)\n  }\n\n  return result\n}\n\n// 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var start = 0\n  var end\n  var length = value.length\n  var result = []\n  var char\n\n  // Move forward past initial white space.\n  while (start <= length) {\n    char = value.charCodeAt(start)\n\n    if (char !== space && char !== tab) {\n      break\n    }\n\n    start++\n  }\n\n  // If we’re not directly after a segment break, but there was white space,\n  // add an empty value that will be turned into a space.\n  if (start !== 0 && !breakBefore) {\n    result.push('')\n  }\n\n  end = next(start - 1)\n\n  while (start < length) {\n    end = end === -1 ? length : end\n    result.push(value.slice(start, end))\n    start = end\n\n    while (start <= length) {\n      char = value.charCodeAt(start)\n\n      if (char !== space && char !== tab) {\n        break\n      }\n\n      start++\n    }\n\n    // If we reached the end, there was trailing white space, and there’s no\n    // segment break after this node, add an empty value that will be turned\n    // into a space.\n    if (start === length && start !== end && !breakAfter) {\n      result.push('')\n    }\n\n    end = next(start)\n  }\n\n  return result.join(' ')\n\n  function next(index) {\n    var spaceIndex = value.indexOf(spaceChar, index + 1)\n    var tabIndex = value.indexOf(tabChar, index + 1)\n    var fn = spaceIndex === -1 || tabIndex === -1 ? max : min\n    return fn(spaceIndex, tabIndex)\n  }\n}\n\n// We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {}\n  var inherit = options.whiteSpace || 'normal'\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre'\n    case 'nobr':\n      return 'nowrap'\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre'\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit\n    case 'textarea':\n      return 'pre-wrap'\n    default:\n      return inherit\n  }\n}\n\nfunction isBidiControlCharacter(char) {\n  switch (char) {\n    case alm:\n    case ltr:\n    case rtl:\n    case lre:\n    case rle:\n    case pdf:\n    case lro:\n    case rlo:\n    case lri:\n    case rli:\n    case fsi:\n    case pdi:\n      return true\n    default:\n      return false\n  }\n}\n\nfunction cell(node) {\n  return is(node, ['th', 'td'])\n}\n\nfunction row(node) {\n  return is(node, ['tr'])\n}\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nfunction blockOrCaption(node) {\n  return is(node, [\n    'caption', // `table-caption`\n    // Page\n    'html',\n    'body',\n    // Flow content\n    'address',\n    'blockquote',\n    'center', // Legacy\n    'dialog',\n    'div',\n    'figure',\n    'figcaption',\n    'footer',\n    'form,',\n    'header',\n    'hr',\n    'legend',\n    'listing', // Legacy\n    'main',\n    'p',\n    'plaintext', // Legacy\n    'pre',\n    'xmp', // Legacy\n    // Sections and headings\n    'article',\n    'aside',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'hgroup',\n    'nav',\n    'section',\n    // Lists\n    'dir', // Legacy\n    'dd',\n    'dl',\n    'dt',\n    'menu',\n    'ol',\n    'ul'\n  ])\n}\n\n// Note that we don’t need to include void elements here as they don’t have text.\n//\n// See: <https://github.com/wooorm/html-void-elements>\nfunction notRendered(node) {\n  var properties = node.properties || {}\n\n  return (\n    // List from: <https://html.spec.whatwg.org/#hidden-elements>\n    is(node, [\n      'datalist',\n      'head',\n      'noembed',\n      'noframes',\n      'rp',\n      'script',\n      'style',\n      'template',\n      'title',\n      // Act as if we support scripting.\n      'noscript'\n    ]) ||\n    // Hidden attribute.\n    properties.hidden ||\n    // From: <https://html.spec.whatwg.org/#flow-content-3>\n    (is(node, 'dialog') && !properties.open)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}