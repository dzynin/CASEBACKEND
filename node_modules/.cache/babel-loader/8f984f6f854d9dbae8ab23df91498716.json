{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar replace = require('replace-ext');\nvar buffer = require('is-buffer');\nmodule.exports = VFile;\nvar own = {}.hasOwnProperty;\nvar proto = VFile.prototype;\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];\nproto.toString = toString;\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(proto, 'path', {\n  get: getPath,\n  set: setPath\n});\n\n// Access parent path (`~`).\nObject.defineProperty(proto, 'dirname', {\n  get: getDirname,\n  set: setDirname\n});\n\n// Access basename (`index.min.js`).\nObject.defineProperty(proto, 'basename', {\n  get: getBasename,\n  set: setBasename\n});\n\n// Access extname (`.js`).\nObject.defineProperty(proto, 'extname', {\n  get: getExtname,\n  set: setExtname\n});\n\n// Access stem (`index.min`).\nObject.defineProperty(proto, 'stem', {\n  get: getStem,\n  set: setStem\n});\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop;\n  var index;\n  var length;\n  if (!options) {\n    options = {};\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {\n      contents: options\n    };\n  } else if ('message' in options && 'messages' in options) {\n    return options;\n  }\n  if (!(this instanceof VFile)) {\n    return new VFile(options);\n  }\n  this.data = {};\n  this.messages = [];\n  this.history = [];\n  this.cwd = process.cwd();\n\n  // Set path related properties in the correct order.\n  index = -1;\n  length = order.length;\n  while (++index < length) {\n    prop = order[index];\n    if (own.call(options, prop)) {\n      this[prop] = options[prop];\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) === -1) {\n      this[prop] = options[prop];\n    }\n  }\n}\nfunction getPath() {\n  return this.history[this.history.length - 1];\n}\nfunction setPath(path) {\n  assertNonEmpty(path, 'path');\n  if (path !== this.path) {\n    this.history.push(path);\n  }\n}\nfunction getDirname() {\n  return typeof this.path === 'string' ? path.dirname(this.path) : undefined;\n}\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname');\n  this.path = path.join(dirname || '', this.basename);\n}\nfunction getBasename() {\n  return typeof this.path === 'string' ? path.basename(this.path) : undefined;\n}\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename');\n  assertPart(basename, 'basename');\n  this.path = path.join(this.dirname || '', basename);\n}\nfunction getExtname() {\n  return typeof this.path === 'string' ? path.extname(this.path) : undefined;\n}\nfunction setExtname(extname) {\n  var ext = extname || '';\n  assertPart(ext, 'extname');\n  assertPath(this.path, 'extname');\n  if (ext) {\n    if (ext.charAt(0) !== '.') {\n      throw new Error('`extname` must start with `.`');\n    }\n    if (ext.indexOf('.', 1) !== -1) {\n      throw new Error('`extname` cannot contain multiple dots');\n    }\n  }\n  this.path = replace(this.path, ext);\n}\nfunction getStem() {\n  return typeof this.path === 'string' ? path.basename(this.path, this.extname) : undefined;\n}\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem');\n  assertPart(stem, 'stem');\n  this.path = path.join(this.dirname || '', stem + (this.extname || ''));\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  var value = this.contents || '';\n  return buffer(value) ? value.toString(encoding) : String(value);\n}\n\n// Assert that `part` is not a path (i.e., does not contain `path.sep`).\nfunction assertPart(part, name) {\n  if (part.indexOf(path.sep) !== -1) {\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + path.sep + '`');\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty');\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\n  }\n}","map":{"version":3,"names":["path","require","replace","buffer","module","exports","VFile","own","hasOwnProperty","proto","prototype","order","toString","Object","defineProperty","get","getPath","set","setPath","getDirname","setDirname","getBasename","setBasename","getExtname","setExtname","getStem","setStem","options","prop","index","length","contents","data","messages","history","cwd","process","call","indexOf","assertNonEmpty","push","dirname","undefined","assertPath","join","basename","assertPart","extname","ext","charAt","Error","stem","encoding","value","String","part","name","sep"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/rehype-katex/node_modules/unified/node_modules/vfile/core.js"],"sourcesContent":["'use strict'\n\nvar path = require('path')\nvar replace = require('replace-ext')\nvar buffer = require('is-buffer')\n\nmodule.exports = VFile\n\nvar own = {}.hasOwnProperty\nvar proto = VFile.prototype\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nproto.toString = toString\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(proto, 'path', {get: getPath, set: setPath})\n\n// Access parent path (`~`).\nObject.defineProperty(proto, 'dirname', {get: getDirname, set: setDirname})\n\n// Access basename (`index.min.js`).\nObject.defineProperty(proto, 'basename', {get: getBasename, set: setBasename})\n\n// Access extname (`.js`).\nObject.defineProperty(proto, 'extname', {get: getExtname, set: setExtname})\n\n// Access stem (`index.min`).\nObject.defineProperty(proto, 'stem', {get: getStem, set: setStem})\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop\n  var index\n  var length\n\n  if (!options) {\n    options = {}\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options}\n  } else if ('message' in options && 'messages' in options) {\n    return options\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options)\n  }\n\n  this.data = {}\n  this.messages = []\n  this.history = []\n  this.cwd = process.cwd()\n\n  // Set path related properties in the correct order.\n  index = -1\n  length = order.length\n\n  while (++index < length) {\n    prop = order[index]\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop]\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) === -1) {\n      this[prop] = options[prop]\n    }\n  }\n}\n\nfunction getPath() {\n  return this.history[this.history.length - 1]\n}\n\nfunction setPath(path) {\n  assertNonEmpty(path, 'path')\n\n  if (path !== this.path) {\n    this.history.push(path)\n  }\n}\n\nfunction getDirname() {\n  return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n}\n\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname')\n  this.path = path.join(dirname || '', this.basename)\n}\n\nfunction getBasename() {\n  return typeof this.path === 'string' ? path.basename(this.path) : undefined\n}\n\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename')\n  assertPart(basename, 'basename')\n  this.path = path.join(this.dirname || '', basename)\n}\n\nfunction getExtname() {\n  return typeof this.path === 'string' ? path.extname(this.path) : undefined\n}\n\nfunction setExtname(extname) {\n  var ext = extname || ''\n\n  assertPart(ext, 'extname')\n  assertPath(this.path, 'extname')\n\n  if (ext) {\n    if (ext.charAt(0) !== '.') {\n      throw new Error('`extname` must start with `.`')\n    }\n\n    if (ext.indexOf('.', 1) !== -1) {\n      throw new Error('`extname` cannot contain multiple dots')\n    }\n  }\n\n  this.path = replace(this.path, ext)\n}\n\nfunction getStem() {\n  return typeof this.path === 'string'\n    ? path.basename(this.path, this.extname)\n    : undefined\n}\n\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem')\n  assertPart(stem, 'stem')\n  this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  var value = this.contents || ''\n  return buffer(value) ? value.toString(encoding) : String(value)\n}\n\n// Assert that `part` is not a path (i.e., does not contain `path.sep`).\nfunction assertPart(part, name) {\n  if (part.indexOf(path.sep) !== -1) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}