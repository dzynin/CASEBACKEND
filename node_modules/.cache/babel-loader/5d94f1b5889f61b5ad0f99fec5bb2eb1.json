{"ast":null,"code":"var util = require('./util');\nmodule.exports = mathInline;\nconst tab = 9; // '\\t'\nconst space = 32; // ' '\nconst dollarSign = 36; // '$'\nconst digit0 = 48; // '0'\nconst digit9 = 57; // '9'\nconst backslash = 92; // '\\\\'\n\nconst classList = ['math', 'math-inline'];\nconst mathDisplay = 'math-display';\nfunction mathInline(options) {\n  const parser = this.Parser;\n  const compiler = this.Compiler;\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser, options);\n  }\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler, options);\n  }\n}\nfunction attachParser(parser, options) {\n  const proto = parser.prototype;\n  const inlineMethods = proto.inlineMethods;\n  mathInlineTokenizer.locator = locator;\n  proto.inlineTokenizers.math = mathInlineTokenizer;\n  inlineMethods.splice(inlineMethods.indexOf('text'), 0, 'math');\n  function locator(value, fromIndex) {\n    return value.indexOf('$', fromIndex);\n  }\n  function mathInlineTokenizer(eat, value, silent) {\n    const length = value.length;\n    let double = false;\n    let escaped = false;\n    let index = 0;\n    let previous;\n    let code;\n    let next;\n    let contentStart;\n    let contentEnd;\n    let valueEnd;\n    let content;\n    if (value.charCodeAt(index) === backslash) {\n      escaped = true;\n      index++;\n    }\n    if (value.charCodeAt(index) !== dollarSign) {\n      return;\n    }\n    index++;\n\n    // Support escaped dollars.\n    if (escaped) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n      return eat(value.slice(0, index))({\n        type: 'text',\n        value: '$'\n      });\n    }\n    if (value.charCodeAt(index) === dollarSign) {\n      double = true;\n      index++;\n    }\n    next = value.charCodeAt(index);\n\n    // Opening fence cannot be followed by a space or a tab.\n    if (next === space || next === tab) {\n      return;\n    }\n    contentStart = index;\n    while (index < length) {\n      code = next;\n      next = value.charCodeAt(index + 1);\n      if (code === dollarSign) {\n        previous = value.charCodeAt(index - 1);\n\n        // Closing fence cannot be preceded by a space or a tab, or followed by\n        // a digit.\n        // If a double marker was used to open, the closing fence must consist\n        // of two dollars as well.\n        if (previous !== space && previous !== tab && (\n        // eslint-disable-next-line no-self-compare\n        next !== next || next < digit0 || next > digit9) && (!double || next === dollarSign)) {\n          contentEnd = index - 1;\n          index++;\n          if (double) {\n            index++;\n          }\n          valueEnd = index;\n          break;\n        }\n      } else if (code === backslash) {\n        index++;\n        next = value.charCodeAt(index + 1);\n      }\n      index++;\n    }\n    if (valueEnd === undefined) {\n      return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n      return true;\n    }\n    content = value.slice(contentStart, contentEnd + 1);\n    return eat(value.slice(0, valueEnd))({\n      type: 'inlineMath',\n      value: content,\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: classList.concat(double && options.inlineMathDouble ? [mathDisplay] : [])\n        },\n        hChildren: [{\n          type: 'text',\n          value: content\n        }]\n      }\n    });\n  }\n}\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype;\n  proto.visitors.inlineMath = compileInlineMath;\n  function compileInlineMath(node) {\n    let fence = '$';\n    const classes = node.data && node.data.hProperties && node.data.hProperties.className || [];\n    if (classes.includes(mathDisplay)) {\n      fence = '$$';\n    }\n    return fence + node.value + fence;\n  }\n}","map":{"version":3,"names":["util","require","module","exports","mathInline","tab","space","dollarSign","digit0","digit9","backslash","classList","mathDisplay","options","parser","Parser","compiler","Compiler","isRemarkParser","attachParser","isRemarkCompiler","attachCompiler","proto","prototype","inlineMethods","mathInlineTokenizer","locator","inlineTokenizers","math","splice","indexOf","value","fromIndex","eat","silent","length","double","escaped","index","previous","code","next","contentStart","contentEnd","valueEnd","content","charCodeAt","slice","type","undefined","data","hName","hProperties","className","concat","inlineMathDouble","hChildren","visitors","inlineMath","compileInlineMath","node","fence","classes","includes"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/remark-math/inline.js"],"sourcesContent":["var util = require('./util')\n\nmodule.exports = mathInline\n\nconst tab = 9 // '\\t'\nconst space = 32 // ' '\nconst dollarSign = 36 // '$'\nconst digit0 = 48 // '0'\nconst digit9 = 57 // '9'\nconst backslash = 92 // '\\\\'\n\nconst classList = ['math', 'math-inline']\nconst mathDisplay = 'math-display'\n\nfunction mathInline(options) {\n  const parser = this.Parser\n  const compiler = this.Compiler\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser, options)\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler, options)\n  }\n}\n\nfunction attachParser(parser, options) {\n  const proto = parser.prototype\n  const inlineMethods = proto.inlineMethods\n\n  mathInlineTokenizer.locator = locator\n\n  proto.inlineTokenizers.math = mathInlineTokenizer\n\n  inlineMethods.splice(inlineMethods.indexOf('text'), 0, 'math')\n\n  function locator(value, fromIndex) {\n    return value.indexOf('$', fromIndex)\n  }\n\n  function mathInlineTokenizer(eat, value, silent) {\n    const length = value.length\n    let double = false\n    let escaped = false\n    let index = 0\n    let previous\n    let code\n    let next\n    let contentStart\n    let contentEnd\n    let valueEnd\n    let content\n\n    if (value.charCodeAt(index) === backslash) {\n      escaped = true\n      index++\n    }\n\n    if (value.charCodeAt(index) !== dollarSign) {\n      return\n    }\n\n    index++\n\n    // Support escaped dollars.\n    if (escaped) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      return eat(value.slice(0, index))({type: 'text', value: '$'})\n    }\n\n    if (value.charCodeAt(index) === dollarSign) {\n      double = true\n      index++\n    }\n\n    next = value.charCodeAt(index)\n\n    // Opening fence cannot be followed by a space or a tab.\n    if (next === space || next === tab) {\n      return\n    }\n\n    contentStart = index\n\n    while (index < length) {\n      code = next\n      next = value.charCodeAt(index + 1)\n\n      if (code === dollarSign) {\n        previous = value.charCodeAt(index - 1)\n\n        // Closing fence cannot be preceded by a space or a tab, or followed by\n        // a digit.\n        // If a double marker was used to open, the closing fence must consist\n        // of two dollars as well.\n        if (\n          previous !== space &&\n          previous !== tab &&\n          // eslint-disable-next-line no-self-compare\n          (next !== next || next < digit0 || next > digit9) &&\n          (!double || next === dollarSign)\n        ) {\n          contentEnd = index - 1\n\n          index++\n\n          if (double) {\n            index++\n          }\n\n          valueEnd = index\n          break\n        }\n      } else if (code === backslash) {\n        index++\n        next = value.charCodeAt(index + 1)\n      }\n\n      index++\n    }\n\n    if (valueEnd === undefined) {\n      return\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n      return true\n    }\n\n    content = value.slice(contentStart, contentEnd + 1)\n\n    return eat(value.slice(0, valueEnd))({\n      type: 'inlineMath',\n      value: content,\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: classList.concat(\n            double && options.inlineMathDouble ? [mathDisplay] : []\n          )\n        },\n        hChildren: [{type: 'text', value: content}]\n      }\n    })\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype\n\n  proto.visitors.inlineMath = compileInlineMath\n\n  function compileInlineMath(node) {\n    let fence = '$'\n    const classes =\n      (node.data && node.data.hProperties && node.data.hProperties.className) ||\n      []\n\n    if (classes.includes(mathDisplay)) {\n      fence = '$$'\n    }\n\n    return fence + node.value + fence\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}