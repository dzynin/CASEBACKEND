{"ast":null,"code":"const util = require('./util');\nmodule.exports = mathBlock;\nconst lineFeed = 10; //  '\\n'\nconst space = 32; // ' '\nconst dollarSign = 36; // '$'\n\nconst lineFeedChar = '\\n';\nconst dollarSignChar = '$';\nconst minFenceCount = 2;\nconst classList = ['math', 'math-display'];\nfunction mathBlock() {\n  const parser = this.Parser;\n  const compiler = this.Compiler;\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser);\n  }\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler);\n  }\n}\nfunction attachParser(parser) {\n  const proto = parser.prototype;\n  const blockMethods = proto.blockMethods;\n  const interruptParagraph = proto.interruptParagraph;\n  const interruptList = proto.interruptList;\n  const interruptBlockquote = proto.interruptBlockquote;\n  proto.blockTokenizers.math = mathBlockTokenizer;\n  blockMethods.splice(blockMethods.indexOf('fencedCode') + 1, 0, 'math');\n\n  // Inject math to interrupt rules\n  interruptParagraph.splice(interruptParagraph.indexOf('fencedCode') + 1, 0, ['math']);\n  interruptList.splice(interruptList.indexOf('fencedCode') + 1, 0, ['math']);\n  interruptBlockquote.splice(interruptBlockquote.indexOf('fencedCode') + 1, 0, ['math']);\n  function mathBlockTokenizer(eat, value, silent) {\n    var length = value.length;\n    var index = 0;\n    let code;\n    let content;\n    let lineEnd;\n    let lineIndex;\n    let openingFenceIndentSize;\n    let openingFenceSize;\n    let openingFenceContentStart;\n    let closingFence;\n    let closingFenceSize;\n    let lineContentStart;\n    let lineContentEnd;\n\n    // Skip initial spacing.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++;\n    }\n    openingFenceIndentSize = index;\n\n    // Skip the fence.\n    while (index < length && value.charCodeAt(index) === dollarSign) {\n      index++;\n    }\n    openingFenceSize = index - openingFenceIndentSize;\n\n    // Exit if there is not enough of a fence.\n    if (openingFenceSize < minFenceCount) {\n      return;\n    }\n\n    // Skip spacing after the fence.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++;\n    }\n    openingFenceContentStart = index;\n\n    // Eat everything after the fence.\n    while (index < length) {\n      code = value.charCodeAt(index);\n\n      // We don’t allow dollar signs here, as that could interfere with inline\n      // math.\n      if (code === dollarSign) {\n        return;\n      }\n      if (code === lineFeed) {\n        break;\n      }\n      index++;\n    }\n    if (value.charCodeAt(index) !== lineFeed) {\n      return;\n    }\n    if (silent) {\n      return true;\n    }\n    content = [];\n    if (openingFenceContentStart !== index) {\n      content.push(value.slice(openingFenceContentStart, index));\n    }\n    index++;\n    lineEnd = value.indexOf(lineFeedChar, index + 1);\n    lineEnd = lineEnd === -1 ? length : lineEnd;\n    while (index < length) {\n      closingFence = false;\n      lineContentStart = index;\n      lineContentEnd = lineEnd;\n      lineIndex = lineEnd;\n      closingFenceSize = 0;\n\n      // First, let’s see if this is a valid closing fence.\n      // Skip trailing white space\n      while (lineIndex > lineContentStart && value.charCodeAt(lineIndex - 1) === space) {\n        lineIndex--;\n      }\n\n      // Skip the fence.\n      while (lineIndex > lineContentStart && value.charCodeAt(lineIndex - 1) === dollarSign) {\n        closingFenceSize++;\n        lineIndex--;\n      }\n\n      // Check if this is a valid closing fence line.\n      if (openingFenceSize <= closingFenceSize && value.indexOf(dollarSignChar, lineContentStart) === lineIndex) {\n        closingFence = true;\n        lineContentEnd = lineIndex;\n      }\n\n      // Sweet, next, we need to trim the line.\n      // Skip initial spacing.\n      while (lineContentStart <= lineContentEnd && lineContentStart - index < openingFenceIndentSize && value.charCodeAt(lineContentStart) === space) {\n        lineContentStart++;\n      }\n\n      // If this is a closing fence, skip final spacing.\n      if (closingFence) {\n        while (lineContentEnd > lineContentStart && value.charCodeAt(lineContentEnd - 1) === space) {\n          lineContentEnd--;\n        }\n      }\n\n      // If this is a content line, or if there is content before the fence:\n      if (!closingFence || lineContentStart !== lineContentEnd) {\n        content.push(value.slice(lineContentStart, lineContentEnd));\n      }\n      if (closingFence) {\n        break;\n      }\n      index = lineEnd + 1;\n      lineEnd = value.indexOf(lineFeedChar, index + 1);\n      lineEnd = lineEnd === -1 ? length : lineEnd;\n    }\n    content = content.join('\\n');\n    return eat(value.slice(0, lineEnd))({\n      type: 'math',\n      value: content,\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: classList.concat()\n        },\n        hChildren: [{\n          type: 'text',\n          value: content\n        }]\n      }\n    });\n  }\n}\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype;\n  proto.visitors.math = compileBlockMath;\n  function compileBlockMath(node) {\n    return '$$\\n' + node.value + '\\n$$';\n  }\n}","map":{"version":3,"names":["util","require","module","exports","mathBlock","lineFeed","space","dollarSign","lineFeedChar","dollarSignChar","minFenceCount","classList","parser","Parser","compiler","Compiler","isRemarkParser","attachParser","isRemarkCompiler","attachCompiler","proto","prototype","blockMethods","interruptParagraph","interruptList","interruptBlockquote","blockTokenizers","math","mathBlockTokenizer","splice","indexOf","eat","value","silent","length","index","code","content","lineEnd","lineIndex","openingFenceIndentSize","openingFenceSize","openingFenceContentStart","closingFence","closingFenceSize","lineContentStart","lineContentEnd","charCodeAt","push","slice","join","type","data","hName","hProperties","className","concat","hChildren","visitors","compileBlockMath","node"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/remark-math/block.js"],"sourcesContent":["const util = require('./util')\n\nmodule.exports = mathBlock\n\nconst lineFeed = 10 //  '\\n'\nconst space = 32 // ' '\nconst dollarSign = 36 // '$'\n\nconst lineFeedChar = '\\n'\nconst dollarSignChar = '$'\n\nconst minFenceCount = 2\n\nconst classList = ['math', 'math-display']\n\nfunction mathBlock() {\n  const parser = this.Parser\n  const compiler = this.Compiler\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser)\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler)\n  }\n}\n\nfunction attachParser(parser) {\n  const proto = parser.prototype\n  const blockMethods = proto.blockMethods\n  const interruptParagraph = proto.interruptParagraph\n  const interruptList = proto.interruptList\n  const interruptBlockquote = proto.interruptBlockquote\n\n  proto.blockTokenizers.math = mathBlockTokenizer\n\n  blockMethods.splice(blockMethods.indexOf('fencedCode') + 1, 0, 'math')\n\n  // Inject math to interrupt rules\n  interruptParagraph.splice(interruptParagraph.indexOf('fencedCode') + 1, 0, [\n    'math'\n  ])\n  interruptList.splice(interruptList.indexOf('fencedCode') + 1, 0, ['math'])\n  interruptBlockquote.splice(interruptBlockquote.indexOf('fencedCode') + 1, 0, [\n    'math'\n  ])\n\n  function mathBlockTokenizer(eat, value, silent) {\n    var length = value.length\n    var index = 0\n    let code\n    let content\n    let lineEnd\n    let lineIndex\n    let openingFenceIndentSize\n    let openingFenceSize\n    let openingFenceContentStart\n    let closingFence\n    let closingFenceSize\n    let lineContentStart\n    let lineContentEnd\n\n    // Skip initial spacing.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++\n    }\n\n    openingFenceIndentSize = index\n\n    // Skip the fence.\n    while (index < length && value.charCodeAt(index) === dollarSign) {\n      index++\n    }\n\n    openingFenceSize = index - openingFenceIndentSize\n\n    // Exit if there is not enough of a fence.\n    if (openingFenceSize < minFenceCount) {\n      return\n    }\n\n    // Skip spacing after the fence.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++\n    }\n\n    openingFenceContentStart = index\n\n    // Eat everything after the fence.\n    while (index < length) {\n      code = value.charCodeAt(index)\n\n      // We don’t allow dollar signs here, as that could interfere with inline\n      // math.\n      if (code === dollarSign) {\n        return\n      }\n\n      if (code === lineFeed) {\n        break\n      }\n\n      index++\n    }\n\n    if (value.charCodeAt(index) !== lineFeed) {\n      return\n    }\n\n    if (silent) {\n      return true\n    }\n\n    content = []\n\n    if (openingFenceContentStart !== index) {\n      content.push(value.slice(openingFenceContentStart, index))\n    }\n\n    index++\n    lineEnd = value.indexOf(lineFeedChar, index + 1)\n    lineEnd = lineEnd === -1 ? length : lineEnd\n\n    while (index < length) {\n      closingFence = false\n      lineContentStart = index\n      lineContentEnd = lineEnd\n      lineIndex = lineEnd\n      closingFenceSize = 0\n\n      // First, let’s see if this is a valid closing fence.\n      // Skip trailing white space\n      while (\n        lineIndex > lineContentStart &&\n        value.charCodeAt(lineIndex - 1) === space\n      ) {\n        lineIndex--\n      }\n\n      // Skip the fence.\n      while (\n        lineIndex > lineContentStart &&\n        value.charCodeAt(lineIndex - 1) === dollarSign\n      ) {\n        closingFenceSize++\n        lineIndex--\n      }\n\n      // Check if this is a valid closing fence line.\n      if (\n        openingFenceSize <= closingFenceSize &&\n        value.indexOf(dollarSignChar, lineContentStart) === lineIndex\n      ) {\n        closingFence = true\n        lineContentEnd = lineIndex\n      }\n\n      // Sweet, next, we need to trim the line.\n      // Skip initial spacing.\n      while (\n        lineContentStart <= lineContentEnd &&\n        lineContentStart - index < openingFenceIndentSize &&\n        value.charCodeAt(lineContentStart) === space\n      ) {\n        lineContentStart++\n      }\n\n      // If this is a closing fence, skip final spacing.\n      if (closingFence) {\n        while (\n          lineContentEnd > lineContentStart &&\n          value.charCodeAt(lineContentEnd - 1) === space\n        ) {\n          lineContentEnd--\n        }\n      }\n\n      // If this is a content line, or if there is content before the fence:\n      if (!closingFence || lineContentStart !== lineContentEnd) {\n        content.push(value.slice(lineContentStart, lineContentEnd))\n      }\n\n      if (closingFence) {\n        break\n      }\n\n      index = lineEnd + 1\n      lineEnd = value.indexOf(lineFeedChar, index + 1)\n      lineEnd = lineEnd === -1 ? length : lineEnd\n    }\n\n    content = content.join('\\n')\n\n    return eat(value.slice(0, lineEnd))({\n      type: 'math',\n      value: content,\n      data: {\n        hName: 'div',\n        hProperties: {className: classList.concat()},\n        hChildren: [{type: 'text', value: content}]\n      }\n    })\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype\n\n  proto.visitors.math = compileBlockMath\n\n  function compileBlockMath(node) {\n    return '$$\\n' + node.value + '\\n$$'\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}