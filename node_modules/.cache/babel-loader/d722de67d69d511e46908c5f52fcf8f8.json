{"ast":null,"code":"const sort = rects => rects.sort((A, B) => {\n  const top = A.top - B.top;\n\n  if (top === 0) {\n    return A.left - B.left;\n  }\n\n  return top;\n});\n\nconst overlaps = (A, B) => A.left <= B.left && B.left <= A.left + A.width;\n\nconst sameLine = (A, B, yMargin = 5) => Math.abs(A.top - B.top) < yMargin && Math.abs(A.height - B.height) < yMargin;\n\nconst inside = (A, B) => A.top > B.top && A.left > B.left && A.top + A.height < B.top + B.height && A.left + A.width < B.left + B.width;\n\nconst nextTo = (A, B, xMargin = 10) => {\n  const Aright = A.left + A.width;\n  const Bright = B.left + B.width;\n  return A.left <= B.left && Aright <= Bright && B.left - Aright <= xMargin;\n};\n\nconst extendWidth = (A, B) => {\n  // extend width of A to cover B\n  A.width = Math.max(B.width - A.left + B.left, A.width);\n};\n\nconst optimizeClientRects = clientRects => {\n  const rects = sort(clientRects);\n  const toRemove = new Set();\n  const firstPass = rects.filter(rect => {\n    return rects.every(otherRect => {\n      return !inside(rect, otherRect);\n    });\n  });\n  let passCount = 0;\n\n  while (passCount <= 2) {\n    firstPass.forEach(A => {\n      firstPass.forEach(B => {\n        if (A === B || toRemove.has(A) || toRemove.has(B)) {\n          return;\n        }\n\n        if (!sameLine(A, B)) {\n          return;\n        }\n\n        if (overlaps(A, B)) {\n          extendWidth(A, B);\n          A.height = Math.max(A.height, B.height);\n          toRemove.add(B);\n        }\n\n        if (nextTo(A, B)) {\n          extendWidth(A, B);\n          toRemove.add(B);\n        }\n      });\n    });\n    passCount += 1;\n  }\n\n  return firstPass.filter(rect => !toRemove.has(rect));\n};\n\nexport default optimizeClientRects;","map":{"version":3,"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONT/gptversion/CASEFRONT/node_modules/react-pdf-highlighter/build/lib/optimize-client-rects.js"],"names":["sort","rects","A","B","top","left","overlaps","width","sameLine","yMargin","Math","abs","height","inside","nextTo","xMargin","Aright","Bright","extendWidth","max","optimizeClientRects","clientRects","toRemove","Set","firstPass","filter","rect","every","otherRect","passCount","forEach","has","add"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,KAAK,IAAIA,KAAK,CAACD,IAAN,CAAW,CAACE,CAAD,EAAIC,CAAJ,KAAU;AACzC,QAAMC,GAAG,GAAGF,CAAC,CAACE,GAAF,GAAQD,CAAC,CAACC,GAAtB;;AAEA,MAAIA,GAAG,KAAK,CAAZ,EAAe;AACb,WAAOF,CAAC,CAACG,IAAF,GAASF,CAAC,CAACE,IAAlB;AACD;;AAED,SAAOD,GAAP;AACD,CARqB,CAAtB;;AAUA,MAAME,QAAQ,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACG,IAAF,IAAUF,CAAC,CAACE,IAAZ,IAAoBF,CAAC,CAACE,IAAF,IAAUH,CAAC,CAACG,IAAF,GAASH,CAAC,CAACK,KAApE;;AAEA,MAAMC,QAAQ,GAAG,CAACN,CAAD,EAAIC,CAAJ,EAAOM,OAAO,GAAG,CAAjB,KAAuBC,IAAI,CAACC,GAAL,CAAST,CAAC,CAACE,GAAF,GAAQD,CAAC,CAACC,GAAnB,IAA0BK,OAA1B,IAAqCC,IAAI,CAACC,GAAL,CAAST,CAAC,CAACU,MAAF,GAAWT,CAAC,CAACS,MAAtB,IAAgCH,OAA7G;;AAEA,MAAMI,MAAM,GAAG,CAACX,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,GAAF,GAAQD,CAAC,CAACC,GAAV,IAAiBF,CAAC,CAACG,IAAF,GAASF,CAAC,CAACE,IAA5B,IAAoCH,CAAC,CAACE,GAAF,GAAQF,CAAC,CAACU,MAAV,GAAmBT,CAAC,CAACC,GAAF,GAAQD,CAAC,CAACS,MAAjE,IAA2EV,CAAC,CAACG,IAAF,GAASH,CAAC,CAACK,KAAX,GAAmBJ,CAAC,CAACE,IAAF,GAASF,CAAC,CAACI,KAAlI;;AAEA,MAAMO,MAAM,GAAG,CAACZ,CAAD,EAAIC,CAAJ,EAAOY,OAAO,GAAG,EAAjB,KAAwB;AACrC,QAAMC,MAAM,GAAGd,CAAC,CAACG,IAAF,GAASH,CAAC,CAACK,KAA1B;AACA,QAAMU,MAAM,GAAGd,CAAC,CAACE,IAAF,GAASF,CAAC,CAACI,KAA1B;AACA,SAAOL,CAAC,CAACG,IAAF,IAAUF,CAAC,CAACE,IAAZ,IAAoBW,MAAM,IAAIC,MAA9B,IAAwCd,CAAC,CAACE,IAAF,GAASW,MAAT,IAAmBD,OAAlE;AACD,CAJD;;AAMA,MAAMG,WAAW,GAAG,CAAChB,CAAD,EAAIC,CAAJ,KAAU;AAC5B;AACAD,EAAAA,CAAC,CAACK,KAAF,GAAUG,IAAI,CAACS,GAAL,CAAShB,CAAC,CAACI,KAAF,GAAUL,CAAC,CAACG,IAAZ,GAAmBF,CAAC,CAACE,IAA9B,EAAoCH,CAAC,CAACK,KAAtC,CAAV;AACD,CAHD;;AAKA,MAAMa,mBAAmB,GAAGC,WAAW,IAAI;AACzC,QAAMpB,KAAK,GAAGD,IAAI,CAACqB,WAAD,CAAlB;AACA,QAAMC,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;AACA,QAAMC,SAAS,GAAGvB,KAAK,CAACwB,MAAN,CAAaC,IAAI,IAAI;AACrC,WAAOzB,KAAK,CAAC0B,KAAN,CAAYC,SAAS,IAAI;AAC9B,aAAO,CAACf,MAAM,CAACa,IAAD,EAAOE,SAAP,CAAd;AACD,KAFM,CAAP;AAGD,GAJiB,CAAlB;AAKA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAOA,SAAS,IAAI,CAApB,EAAuB;AACrBL,IAAAA,SAAS,CAACM,OAAV,CAAkB5B,CAAC,IAAI;AACrBsB,MAAAA,SAAS,CAACM,OAAV,CAAkB3B,CAAC,IAAI;AACrB,YAAID,CAAC,KAAKC,CAAN,IAAWmB,QAAQ,CAACS,GAAT,CAAa7B,CAAb,CAAX,IAA8BoB,QAAQ,CAACS,GAAT,CAAa5B,CAAb,CAAlC,EAAmD;AACjD;AACD;;AAED,YAAI,CAACK,QAAQ,CAACN,CAAD,EAAIC,CAAJ,CAAb,EAAqB;AACnB;AACD;;AAED,YAAIG,QAAQ,CAACJ,CAAD,EAAIC,CAAJ,CAAZ,EAAoB;AAClBe,UAAAA,WAAW,CAAChB,CAAD,EAAIC,CAAJ,CAAX;AACAD,UAAAA,CAAC,CAACU,MAAF,GAAWF,IAAI,CAACS,GAAL,CAASjB,CAAC,CAACU,MAAX,EAAmBT,CAAC,CAACS,MAArB,CAAX;AACAU,UAAAA,QAAQ,CAACU,GAAT,CAAa7B,CAAb;AACD;;AAED,YAAIW,MAAM,CAACZ,CAAD,EAAIC,CAAJ,CAAV,EAAkB;AAChBe,UAAAA,WAAW,CAAChB,CAAD,EAAIC,CAAJ,CAAX;AACAmB,UAAAA,QAAQ,CAACU,GAAT,CAAa7B,CAAb;AACD;AACF,OAnBD;AAoBD,KArBD;AAsBA0B,IAAAA,SAAS,IAAI,CAAb;AACD;;AAED,SAAOL,SAAS,CAACC,MAAV,CAAiBC,IAAI,IAAI,CAACJ,QAAQ,CAACS,GAAT,CAAaL,IAAb,CAA1B,CAAP;AACD,CArCD;;AAuCA,eAAeN,mBAAf","sourcesContent":["const sort = rects => rects.sort((A, B) => {\n  const top = A.top - B.top;\n\n  if (top === 0) {\n    return A.left - B.left;\n  }\n\n  return top;\n});\n\nconst overlaps = (A, B) => A.left <= B.left && B.left <= A.left + A.width;\n\nconst sameLine = (A, B, yMargin = 5) => Math.abs(A.top - B.top) < yMargin && Math.abs(A.height - B.height) < yMargin;\n\nconst inside = (A, B) => A.top > B.top && A.left > B.left && A.top + A.height < B.top + B.height && A.left + A.width < B.left + B.width;\n\nconst nextTo = (A, B, xMargin = 10) => {\n  const Aright = A.left + A.width;\n  const Bright = B.left + B.width;\n  return A.left <= B.left && Aright <= Bright && B.left - Aright <= xMargin;\n};\n\nconst extendWidth = (A, B) => {\n  // extend width of A to cover B\n  A.width = Math.max(B.width - A.left + B.left, A.width);\n};\n\nconst optimizeClientRects = clientRects => {\n  const rects = sort(clientRects);\n  const toRemove = new Set();\n  const firstPass = rects.filter(rect => {\n    return rects.every(otherRect => {\n      return !inside(rect, otherRect);\n    });\n  });\n  let passCount = 0;\n\n  while (passCount <= 2) {\n    firstPass.forEach(A => {\n      firstPass.forEach(B => {\n        if (A === B || toRemove.has(A) || toRemove.has(B)) {\n          return;\n        }\n\n        if (!sameLine(A, B)) {\n          return;\n        }\n\n        if (overlaps(A, B)) {\n          extendWidth(A, B);\n          A.height = Math.max(A.height, B.height);\n          toRemove.add(B);\n        }\n\n        if (nextTo(A, B)) {\n          extendWidth(A, B);\n          toRemove.add(B);\n        }\n      });\n    });\n    passCount += 1;\n  }\n\n  return firstPass.filter(rect => !toRemove.has(rect));\n};\n\nexport default optimizeClientRects;"]},"metadata":{},"sourceType":"module"}